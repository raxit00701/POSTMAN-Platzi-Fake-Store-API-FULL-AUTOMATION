{
	"info": {
		"_postman_id": "71c061b7-1ffd-44f3-8fbe-4f4535017a2e",
		"name": "Positive test cases",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "44003382",
		"_collection_link": "https://www.postman.com/drive3/workspace/postman-project/collection/44003382-71c061b7-1ffd-44f3-8fbe-4f4535017a2e?action=share&source=collection_link&creator=44003382"
	},
	"item": [
		{
			"name": "Products",
			"item": [
				{
					"name": "products",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"(function () {\r",
									"  // 1) Status check (kept simple)\r",
									"  pm.test(\"Status is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"  });\r",
									"\r",
									"  // Content-Type sanity (kept simple)\r",
									"  pm.test(\"Content-Type is JSON\", function () {\r",
									"    const ct = pm.response.headers.get(\"Content-Type\") || \"\";\r",
									"    pm.expect(ct.toLowerCase()).to.include(\"application/json\");\r",
									"  });\r",
									"\r",
									"  // Body: just verify it's a JSON array (no length or deep shape checks)\r",
									"  let arr;\r",
									"  pm.test(\"Body is a JSON array\", function () {\r",
									"    arr = pm.response.json();\r",
									"    pm.expect(arr).to.be.an(\"array\");\r",
									"  });\r",
									"\r",
									"  // (Removed)\r",
									"  // - Response time assertion\r",
									"  // - Helper functions (isUrl)\r",
									"  // - validateProduct() and per-field checks\r",
									"  // - Loop validating first N items\r",
									"})();\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disabledSystemHeaders": {
							"connection": true
						}
					},
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/products",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create product",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Assert HTTP status\r",
									"pm.test(\"Status is 201 Created\", function () {\r",
									"  pm.response.to.have.status(201);\r",
									"});\r",
									"\r",
									"// Assert JSON Content-Type\r",
									"pm.test(\"Content-Type is JSON\", function () {\r",
									"  const ct = (pm.response.headers.get(\"Content-Type\") || \"\").toLowerCase();\r",
									"  pm.expect(ct).to.include(\"application/json\");\r",
									"});\r",
									"\r",
									"// Parse JSON\r",
									"let json;\r",
									"pm.test(\"Response is valid JSON object\", function () {\r",
									"  json = pm.response.json();\r",
									"  pm.expect(json).to.be.an(\"object\");\r",
									"});\r",
									"\r",
									"// Helpers (robust) — kept as-is (unused now, but not modifying non-assert code)\r",
									"const isIso = s => typeof s === \"string\" && !Number.isNaN(Date.parse(s));\r",
									"\r",
									"// Top-level fields (simplified: only basic presence)\r",
									"pm.test(\"Has basic top-level fields\", function () {\r",
									"  pm.expect(json).to.have.property(\"id\");\r",
									"  pm.expect(json).to.have.property(\"title\");\r",
									"  // Optional presence only; no type/range/ISO checks\r",
									"});\r",
									"\r",
									"// Category object (simplified: existence only)\r",
									"pm.test(\"Category object exists\", function () {\r",
									"  pm.expect(json).to.have.property(\"category\");\r",
									"});\r",
									"\r",
									"// Images (simplified: if present and array, that's fine; no non-empty/URL loops)\r",
									"pm.test(\"Images field sanity\", function () {\r",
									"  if (json.hasOwnProperty(\"images\")) {\r",
									"    pm.expect(Array.isArray(json.images)).to.be.true;\r",
									"  }\r",
									"});\r",
									"\r",
									"// Capture to collection variables (simplified assertions)\r",
									"pm.test(\"Store ProductSlug (collection variable)\", function () {\r",
									"  pm.expect(json).to.have.property(\"slug\");\r",
									"  pm.collectionVariables.set(\"ProductSlug\", String(json.slug));\r",
									"});\r",
									"\r",
									"pm.test(\"Store productId (collection variable)\", function () {\r",
									"  pm.expect(json).to.have.property(\"id\");\r",
									"  pm.collectionVariables.set(\"productId\", String(json.id));\r",
									"});\r",
									"\r",
									"pm.test(\"Store ProductTitle (collection variable)\", function () {\r",
									"  pm.expect(json).to.have.property(\"title\");\r",
									"  pm.collectionVariables.set(\"ProductTitle\", String(json.title));\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// --- Generate unique-ish title + slug every run ----------------------------\r",
									"const pick = (a) => a[Math.floor(Math.random() * a.length)];\r",
									"const adjectives = [\"Classic\",\"Modern\",\"Premium\",\"Urban\",\"Cozy\",\"Bold\",\"Smart\",\"Elegant\",\"Heritage\",\"Everyday\",\"Elite\",\"Royal\"];\r",
									"const items = [\"Hoodie\",\"Tee\",\"Cap\",\"Sneakers\",\"Backpack\",\"Watch\",\"Lamp\",\"Mug\",\"Jacket\",\"Shirt\",\"Pants\",\"Table\"];\r",
									"\r",
									"// short unique token: timestamp tail + base36 chunk\r",
									"const token = `${Date.now().toString().slice(-6)}-${Math.random().toString(36).slice(2,6)}`;\r",
									"\r",
									"const baseTitle = `${pick(adjectives)} ${pick(items)}`;\r",
									"const title = `${baseTitle} ${token}`; // ensures uniqueness like: \"Modern Hoodie 664912-k3fz\"\r",
									"\r",
									"const slugify = (s) => String(s || \"\")\r",
									"  .trim()\r",
									"  .toLowerCase()\r",
									"  .replace(/[^a-z0-9]+/g, \"-\")\r",
									"  .replace(/^-+|-+$/g, \"\");\r",
									"\r",
									"const slug = slugify(title);\r",
									"\r",
									"// --- Update outgoing JSON body ---------------------------------------------\r",
									"let body = {};\r",
									"try {\r",
									"  body = pm.request.body?.raw ? JSON.parse(pm.request.body.raw) : {};\r",
									"} catch { body = {}; }\r",
									"\r",
									"body.title = title;\r",
									"\r",
									"// If your API allows sending slug explicitly, keep next line.\r",
									"// If your API *always* derives slug, you can remove it.\r",
									"body.slug = slug;\r",
									"\r",
									"// Make sure price is a number >= 0 (optional hardening)\r",
									"if (typeof body.price !== \"number\" || Number.isNaN(body.price)) {\r",
									"  body.price = Math.floor(Math.random() * 500) + 10; // 10..509\r",
									"}\r",
									"\r",
									"// Ensure images array exists (optional)\r",
									"if (!Array.isArray(body.images) || body.images.length === 0) {\r",
									"  body.images = [\"https://placehold.co/600x400\"];\r",
									"}\r",
									"\r",
									"// Content-Type + write back\r",
									"pm.request.headers.upsert({ key: \"Content-Type\", value: \"application/json\" });\r",
									"pm.request.body.update(JSON.stringify(body, null, 2));\r",
									"\r",
									"console.log(\"🆕 title:\", body.title, \"🔗 slug:\", body.slug);\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"title\": \"{{Product}}\",\r\n  \"price\": 10,\r\n  \"description\": \"A description\",\r\n  \"categoryId\": 10,\r\n  \"images\": [\"https://placehold.co/600x400\"]\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseurl}}/products/",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products",
								""
							]
						}
					},
					"response": []
				},
				{
					"name": "Get a single product by id",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Assert HTTP status\r",
									"pm.test(\"Status is 200 OK\", function () {            // (name tweak only)\r",
									"  pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"// Assert JSON Content-Type\r",
									"pm.test(\"Content-Type is JSON\", function () {\r",
									"  const ct = (pm.response.headers.get(\"Content-Type\") || \"\").toLowerCase();\r",
									"  pm.expect(ct).to.include(\"application/json\");\r",
									"});\r",
									"\r",
									"// Parse JSON\r",
									"let json;\r",
									"pm.test(\"Response is valid JSON object\", function () {\r",
									"  json = pm.response.json();\r",
									"  pm.expect(json).to.be.an(\"object\");\r",
									"});\r",
									"\r",
									"// Helpers\r",
									"const isIso = s => typeof s === \"string\" && /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/.test(s);\r",
									"\r",
									"// Top-level fields\r",
									"pm.test(\"Has required top-level fields with correct types\", function () {\r",
									"  pm.expect(json).to.have.property(\"id\").that.is.a(\"number\");\r",
									"  pm.expect(Number.isInteger(json.id)).to.be.true;\r",
									"\r",
									"  pm.expect(json).to.have.property(\"title\").that.is.a(\"string\").and.not.empty;\r",
									"  pm.expect(json).to.have.property(\"slug\").that.is.a(\"string\").and.not.empty;\r",
									"\r",
									"  pm.expect(json).to.have.property(\"price\").that.is.a(\"number\");\r",
									"  pm.expect(json.price).to.be.at.least(0);\r",
									"\r",
									"  pm.expect(json).to.have.property(\"description\").that.is.a(\"string\");\r",
									"\r",
									"  pm.expect(json).to.have.property(\"creationAt\").that.is.a(\"string\");\r",
									"  pm.expect(json).to.have.property(\"updatedAt\").that.is.a(\"string\");\r",
									"  pm.expect(isIso(json.creationAt)).to.be.true;\r",
									"  pm.expect(isIso(json.updatedAt)).to.be.true;\r",
									"  pm.expect(new Date(json.updatedAt) >= new Date(json.creationAt)).to.be.true;\r",
									"});\r",
									"\r",
									"// Category object\r",
									"pm.test(\"Category object is valid\", function () {\r",
									"  pm.expect(json).to.have.property(\"category\").that.is.an(\"object\");\r",
									"  const c = json.category;\r",
									"\r",
									"  pm.expect(c).to.have.property(\"id\").that.is.a(\"number\");\r",
									"  pm.expect(Number.isInteger(c.id)).to.be.true;\r",
									"\r",
									"  pm.expect(c).to.have.property(\"name\").that.is.a(\"string\").and.not.empty;\r",
									"  pm.expect(c).to.have.property(\"slug\").that.is.a(\"string\").and.not.empty;\r",
									"\r",
									"  pm.expect(c).to.have.property(\"image\").that.is.a(\"string\");\r",
									"\r",
									"  pm.expect(c).to.have.property(\"creationAt\").that.is.a(\"string\");\r",
									"  pm.expect(c).to.have.property(\"updatedAt\").that.is.a(\"string\");\r",
									"  pm.expect(isIso(c.creationAt)).to.be.true;\r",
									"  pm.expect(isIso(c.updatedAt)).to.be.true;\r",
									"});\r",
									"\r",
									"// Images array\r",
									"pm.test(\"Images is a non-empty array of valid URLs\", function () {\r",
									"  // ★ Some APIs return a single string instead of array\r",
									"  let imgs = json.images;\r",
									"  if (typeof imgs === \"string\") imgs = [imgs];\r",
									"\r",
									"  pm.expect(imgs, \"images\").to.be.an(\"array\").with.length.greaterThan(0);\r",
									"\r",
									"  imgs.forEach((u, i) => {\r",
									"    pm.expect(u, `images[${i}]`).to.be.a(\"string\").and.not.empty;\r",
									"  });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/products/{{productId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products",
								"{{productId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Pagination",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// 4) Assertion: response is 200 OK\r",
									"pm.test(\"Status is 200 OK\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"// (Removed) Response time assertion\r",
									"\r",
									"// 1) Validate the JSON response body (kept minimal)\r",
									"let dat2;\r",
									"pm.test(\"Body is a JSON array of products\", function () {\r",
									"  dat2 = pm.response.json();\r",
									"  pm.expect(dat2).to.be.an(\"array\"); // no length or per-item checks\r",
									"});\r",
									"\r",
									"// Simple helper\r",
									"const isUrl = (s) => {\r",
									"  try { new URL(s); return true; } catch { return false; }\r",
									"};\r",
									"\r",
									"// Simplified: no per-field/type validations, no loops\r",
									"pm.test(\"Each product has expected shape & types\", function () {\r",
									"  if (Array.isArray(dat2) && dat2.length > 0) {\r",
									"    pm.expect(dat2[0]).to.be.an(\"object\"); // sanity check only on first item\r",
									"  }\r",
									"});\r",
									"\r",
									"// 2) Print to console\r",
									"console.log(\"response is verified\");\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/products?offset=0&limit=10",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products"
							],
							"query": [
								{
									"key": "offset",
									"value": "0"
								},
								{
									"key": "limit",
									"value": "10"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Get products related by id",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// 1) Assertion: 200 OK\r",
									"pm.test(\"Status is 200 OK\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"// (Removed) 2) Assertion: response time < 3000 ms\r",
									"\r",
									"// 3) Validate JSON response body (minimal)\r",
									"let da3;\r",
									"pm.test(\"Body is a JSON array\", function () {\r",
									"  da3 = pm.response.json();\r",
									"  pm.expect(da3).to.be.an(\"array\"); // no length requirement\r",
									"});\r",
									"\r",
									"// Helpers (left intact; not assertions)\r",
									"const isUrl = s => { try { new URL(s); return true; } catch { return false; } };\r",
									"const isIso = s => typeof s === \"string\" && /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/.test(s);\r",
									"\r",
									"// Validate a single product shape (assertions simplified)\r",
									"function validateProduct(p, idx) {\r",
									"  pm.expect(p, `item[${idx}]`).to.be.an(\"object\");\r",
									"\r",
									"  // minimal presence checks only\r",
									"  pm.expect(p).to.have.property(\"id\");\r",
									"  pm.expect(p).to.have.property(\"title\");\r",
									"\r",
									"  // (Removed) types, ranges, timestamps, category/images structure, loops, etc.\r",
									"}\r",
									"\r",
									"// Validate first few items (kept; assertions inside are minimal now)\r",
									"pm.test(\"Validate product items (basic presence)\", function () {\r",
									"  const N = Math.min(5, da3.length);\r",
									"  for (let i = 0; i < N; i++) validateProduct(da3[i], i);\r",
									"});\r",
									"\r",
									"// 4) Print confirmation\r",
									"console.log(\"response is verified\");\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/products/{{productId}}/related",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products",
								"{{productId}}",
								"related"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get a single product by slug",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// 1) Assert: 200 OK\r",
									"pm.test(\"Status is 200 OK\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"// 2) Assert: response time < 3000 ms\r",
									"pm.test(\"Response time < 3000 ms\", function () {\r",
									"    pm.expect(pm.response.responseTime).to.be.below(3000);\r",
									"});\r",
									"\r",
									"// 3) Validate JSON response body (explicit + simple, dynamic)\r",
									"let body;\r",
									"pm.test(\"Body is a JSON object\", function () {\r",
									"    body = pm.response.json();\r",
									"    pm.expect(body).to.be.an(\"object\");\r",
									"});\r",
									"\r",
									"// Helpers\r",
									"const isIso = s => typeof s === \"string\" && /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d{3})?Z$/.test(s);\r",
									"\r",
									"// Required top-level fields\r",
									"pm.test(\"Required fields present with correct types\", function () {\r",
									"    pm.expect(body).to.have.property(\"id\");\r",
									"    pm.expect(Number.isInteger(body.id)).to.be.true;\r",
									"\r",
									"    pm.expect(body).to.have.property(\"title\").that.is.a(\"string\").and.not.empty;\r",
									"    pm.expect(body).to.have.property(\"slug\").that.is.a(\"string\").and.not.empty;\r",
									"\r",
									"    pm.expect(body).to.have.property(\"price\").that.is.a(\"number\");\r",
									"    pm.expect(body.price).to.be.at.least(0);\r",
									"\r",
									"    pm.expect(body).to.have.property(\"description\").that.is.a(\"string\");\r",
									"\r",
									"    pm.expect(body).to.have.property(\"creationAt\").that.is.a(\"string\");\r",
									"    pm.expect(body).to.have.property(\"updatedAt\").that.is.a(\"string\");\r",
									"    pm.expect(isIso(body.creationAt)).to.be.true;\r",
									"    pm.expect(isIso(body.updatedAt)).to.be.true;\r",
									"});\r",
									"\r",
									"// Category object\r",
									"pm.test(\"Category object is valid\", function () {\r",
									"    pm.expect(body).to.have.property(\"category\").that.is.an(\"object\");\r",
									"    const c = body.category;\r",
									"\r",
									"    pm.expect(c).to.have.property(\"id\");\r",
									"    pm.expect(Number.isInteger(c.id)).to.be.true;\r",
									"\r",
									"    pm.expect(c).to.have.property(\"name\").that.is.a(\"string\").and.not.empty;\r",
									"    pm.expect(c).to.have.property(\"slug\").that.is.a(\"string\").and.not.empty;\r",
									"\r",
									"    pm.expect(c).to.have.property(\"image\").that.is.a(\"string\");\r",
									"\r",
									"    pm.expect(c).to.have.property(\"creationAt\").that.is.a(\"string\");\r",
									"    pm.expect(c).to.have.property(\"updatedAt\").that.is.a(\"string\");\r",
									"    pm.expect(isIso(c.creationAt)).to.be.true;\r",
									"    pm.expect(isIso(c.updatedAt)).to.be.true;\r",
									"});\r",
									"\r",
									"// Images array\r",
									"pm.test(\"Images is a non-empty array of valid URLs\", function () {\r",
									"    let imgs = body.images;\r",
									"    if (typeof imgs === \"string\") imgs = [imgs];\r",
									"\r",
									"    pm.expect(imgs, \"images\").to.be.an(\"array\").with.length.greaterThan(0);\r",
									"\r",
									"    imgs.forEach((u, i) => {\r",
									"        pm.expect(u, `images[${i}]`).to.be.a(\"string\").and.not.empty;\r",
									"    });\r",
									"});\r",
									"\r",
									"// 4) Print confirmation\r",
									"console.log(\"✅ JSON body is strictly verified\");"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/products/slug/{{ProductSlug}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products",
								"slug",
								"{{ProductSlug}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get products related by slug",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// 1) Assertion: 200 OK\r",
									"pm.test(\"Status is 200 OK\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"// (Removed) 2) Assertion: response time < 3000 ms\r",
									"\r",
									"// 3) Validate response JSON body (minimal)\r",
									"let da1 = pm.response.json();\r",
									"\r",
									"pm.test(\"Body is an array\", function () {\r",
									"  pm.expect(da1).to.be.an(\"array\"); // no length requirement\r",
									"});\r",
									"\r",
									"// Helpers (left intact)\r",
									"const isUrl = s => { try { new URL(s); return true; } catch { return false; } };\r",
									"const isIso = s => typeof s === \"string\" && /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/.test(s);\r",
									"\r",
									"// Validate product items (simplified assertions only)\r",
									"pm.test(\"Validate product items (basic presence)\", function () {\r",
									"  const N = Math.min(5, da1.length);\r",
									"  for (let i = 0; i < N; i++) {\r",
									"    const p = da1[i];\r",
									"    pm.expect(p, `item[${i}]`).to.be.an(\"object\");\r",
									"    pm.expect(p).to.have.property(\"id\");\r",
									"    pm.expect(p).to.have.property(\"title\");\r",
									"    // (Removed) type/range checks, timestamps, category/images validations, loops over images, etc.\r",
									"  }\r",
									"});\r",
									"\r",
									"// 4) Print on console\r",
									"console.log(\"json body is verified\");\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/products/slug/{{ProductSlug}}/related",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products",
								"slug",
								"{{ProductSlug}}",
								"related"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update Product",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// 1) Assertion: 200 OK\r",
									"pm.test(\"Status is 200 OK\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"// 2) Assertion: response time < 3000 ms\r",
									"pm.test(\"Response time < 3000 ms\", function () {\r",
									"  pm.expect(pm.response.responseTime).to.be.below(3000);\r",
									"});\r",
									"\r",
									"// 3) Validate response JSON body (explicit + simple)\r",
									"let json = pm.response.json();\r",
									"\r",
									"// Helpers\r",
									"// More tolerant ISO check (accepts with/without milliseconds and TZ offsets)\r",
									"const isIso = s => typeof s === \"string\" && !Number.isNaN(Date.parse(s));\r",
									"\r",
									"// Top-level checks\r",
									"pm.test(\"Body has required top-level fields with correct types\", function () {\r",
									"  pm.expect(json).to.be.an(\"object\");\r",
									"\r",
									"  pm.expect(json).to.have.property(\"id\");\r",
									"  pm.expect(Number.isInteger(json.id)).to.be.true;\r",
									"  pm.expect(json.id).to.be.greaterThan(0);\r",
									"\r",
									"  pm.expect(json).to.have.property(\"title\").that.is.a(\"string\").and.not.empty;\r",
									"  pm.expect(json).to.have.property(\"slug\").that.is.a(\"string\").and.not.empty;\r",
									"\r",
									"  pm.expect(json).to.have.property(\"price\").that.is.a(\"number\");\r",
									"  pm.expect(json.price).to.be.at.least(0);\r",
									"\r",
									"  pm.expect(json).to.have.property(\"description\").that.is.a(\"string\");\r",
									"\r",
									"  pm.expect(json).to.have.property(\"creationAt\").that.is.a(\"string\");\r",
									"  pm.expect(json).to.have.property(\"updatedAt\").that.is.a(\"string\");\r",
									"  pm.expect(isIso(json.creationAt)).to.be.true;\r",
									"  pm.expect(isIso(json.updatedAt)).to.be.true;\r",
									"  pm.expect(new Date(json.updatedAt) >= new Date(json.creationAt)).to.be.true;\r",
									"\r",
									"  // images: coerce string → array, then validate\r",
									"  let imgs = json.images;\r",
									"  if (typeof imgs === \"string\") imgs = [imgs];\r",
									"  pm.expect(imgs, \"images\").to.be.an(\"array\").with.length.greaterThan(0);\r",
									"\r",
									"  imgs.forEach((u, i) => {\r",
									"    pm.expect(u, `images[${i}]`).to.be.a(\"string\").and.not.empty;\r",
									"  });\r",
									"});\r",
									"\r",
									"// Category checks\r",
									"pm.test(\"Category object is valid\", function () {\r",
									"  pm.expect(json).to.have.property(\"category\").that.is.an(\"object\");\r",
									"  const c = json.category;\r",
									"\r",
									"  pm.expect(c).to.have.property(\"id\");\r",
									"  pm.expect(Number.isInteger(c.id)).to.be.true;\r",
									"\r",
									"  pm.expect(c).to.have.property(\"name\").that.is.a(\"string\").and.not.empty;\r",
									"  pm.expect(c).to.have.property(\"slug\").that.is.a(\"string\").and.not.empty;\r",
									"\r",
									"  pm.expect(c).to.have.property(\"image\").that.is.a(\"string\");\r",
									"\r",
									"  pm.expect(c).to.have.property(\"creationAt\").that.is.a(\"string\");\r",
									"  pm.expect(c).to.have.property(\"updatedAt\").that.is.a(\"string\");\r",
									"  pm.expect(isIso(c.creationAt)).to.be.true;\r",
									"  pm.expect(isIso(c.updatedAt)).to.be.true;\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Pre-request: generate a new title for UPDATE (PUT)\r",
									"// Always creates \"brand + 6-digit number\" and saves to collection var \"UpdateTitle\"\r",
									"\r",
									"const brands = [\r",
									"  \"Nissan\",\"Toyota\",\"Honda\",\"BMW\",\"Audi\",\"Ford\",\"Hyundai\",\r",
									"  \"Tata\",\"Mahindra\",\"Kia\",\"Suzuki\",\"Chevrolet\",\"Mercedes\",\r",
									"  \"Volvo\",\"Skoda\",\"Renault\",\"Jaguar\",\"Lexus\",\"Porsche\"\r",
									"];\r",
									"\r",
									"const brand  = brands[Math.floor(Math.random() * brands.length)];\r",
									"const digits = (Date.now() % 1e6).toString().padStart(6, \"0\");\r",
									"const newTitle = `${brand} ${digits}`;\r",
									"\r",
									"pm.collectionVariables.set(\"UpdateTitle\", newTitle);\r",
									"// console.log(\"UpdateTitle:\", newTitle);\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"title\": \"{{UpdateTitle}}\",\r\n  \"price\": 100\r\n}\r\n",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseurl}}/products/{{productId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products",
								"{{productId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "delete a product",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// 1) Assertion: 200 OK\r",
									"pm.test(\"Status is 200 OK\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"// 2) Assertion: response time < 3000 ms\r",
									"pm.test(\"Response time < 3000 ms\", function () {\r",
									"  pm.expect(pm.response.responseTime).to.be.below(3000);\r",
									"});\r",
									"\r",
									"// 4) Print on console\r",
									"console.log(\"Product deleted\");"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"body": {
							"mode": "urlencoded",
							"urlencoded": []
						},
						"url": {
							"raw": "{{baseurl}}/products/{{productId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products",
								"{{productId}}"
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"requests": {},
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"requests": {},
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Categories",
			"item": [
				{
					"name": "Categories",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Assert status code is 200\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"// Parse response JSON\r",
									"let jsonData1;\r",
									"try {\r",
									"    jsonData1 = pm.response.json();\r",
									"} catch (e) {\r",
									"    pm.test(\"Response is valid JSON\", function () {\r",
									"        throw new Error(\"Response is not valid JSON\");\r",
									"    });\r",
									"}\r",
									"\r",
									"// Validate response is an array\r",
									"pm.test(\"Response is an array\", function () {\r",
									"    pm.expect(Array.isArray(jsonData1)).to.be.true;\r",
									"});\r",
									"\r",
									"// Print how many objects are in the response\r",
									"console.log(\"📦 Total items in response:\", jsonData1.length);\r",
									"\r",
									"// Dynamically validate each object\r",
									"jsonData1.forEach((item, index) => {\r",
									"    pm.test(`Item ${index + 1} has required fields`, function () {\r",
									"        pm.expect(item).to.have.property(\"id\");\r",
									"        pm.expect(item).to.have.property(\"name\");\r",
									"        pm.expect(item).to.have.property(\"slug\");\r",
									"        pm.expect(item).to.have.property(\"image\");\r",
									"        pm.expect(item).to.have.property(\"creationAt\");\r",
									"        pm.expect(item).to.have.property(\"updatedAt\");\r",
									"    });\r",
									"});\r",
									"\r",
									"// JSON Schema validation\r",
									"const schema = {\r",
									"  type: \"array\",\r",
									"  items: {\r",
									"    type: \"object\",\r",
									"    required: [\"id\",\"name\",\"slug\",\"image\",\"creationAt\",\"updatedAt\"],\r",
									"    properties: {\r",
									"      id:         { type: \"integer\" },\r",
									"      name:       { type: \"string\" },\r",
									"      slug:       { type: \"string\" },\r",
									"      // Accept only http/https, no spaces\r",
									"      image:      { type: \"string\", pattern: \"^https?://\\\\S+$\" },\r",
									"      creationAt: { type: \"string\", format: \"date-time\" },\r",
									"      updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"    },\r",
									"    additionalProperties: true\r",
									"  }\r",
									"};\r",
									"\r",
									"\r",
									"\r",
									"pm.test(\"Response matches JSON schema\", function () {\r",
									"    pm.response.to.have.jsonSchema(schema);\r",
									"});\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/categories",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"categories"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create a category",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// --- 1) Generate a natural category name ---\r",
									"const pick = (a) => a[Math.floor(Math.random() * a.length)];\r",
									"const adjectives = [\"Royal\",\"Modern\",\"Classic\",\"Premium\",\"Urban\",\"Vintage\",\"Eco\",\"Cozy\",\"Elegant\",\"Fresh\",\"Bold\",\"Smart\",\"Heritage\",\"Everyday\",\"Elite\"];\r",
									"const nouns      = [\"Items\",\"Essentials\",\"Collection\",\"Goods\",\"Styles\",\"Basics\",\"Picks\",\"Edition\",\"Finds\",\"Threads\",\"Wardrobe\",\"Selection\"];\r",
									"\r",
									"const generatedName = `${pick(adjectives)} ${pick(nouns)}`;\r",
									"\r",
									"// --- 2) Set Postman variable {{New Category}} (as requested) ---\r",
									"pm.collectionVariables.set(\"New Category\", generatedName);\r",
									"\r",
									"// --- 3) Read current raw JSON body (or start fresh) ---\r",
									"let body = {};\r",
									"try {\r",
									"  body = pm.request.body && pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};\r",
									"} catch (e) {\r",
									"  body = {};\r",
									"}\r",
									"\r",
									"// --- 4) Inject the name (using the variable value) ---\r",
									"body.name = pm.collectionVariables.get(\"New Category\");\r",
									"\r",
									"// keep existing image if provided; otherwise leave as-is or set a default\r",
									"body.image = body.image || \"https://placeimg.com/640/480/any\";\r",
									"\r",
									"// --- 5) Update the outgoing request body ---\r",
									"pm.request.headers.upsert({ key: \"Content-Type\", value: \"application/json\" });\r",
									"pm.request.body.update(JSON.stringify(body, null, 2));\r",
									"\r",
									"// (Optional) visibility\r",
									"console.log(\"Generated {{New Category}}:\", pm.collectionVariables.get(\"New Category\"));\r",
									"console.log(\"Outgoing payload:\", body);\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- 1) Status + parse ------------------------------------------------------\r",
									"pm.test(\"201 Created\", function () {\r",
									"  pm.response.to.have.status(201);\r",
									"  pm.response.to.be.withBody;\r",
									"  pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"let res;\r",
									"try { res = pm.response.json(); } catch (e) { res = null; }\r",
									"pm.expect(res, \"Response JSON required\").to.be.an(\"object\");\r",
									"\r",
									"console.log(\"✅ Created category response:\", res);\r",
									"\r",
									"// Read the request body to compare expected fields\r",
									"let reqBody = {};\r",
									"try { reqBody = pm.request.body && pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {}; } catch (e) { /* ignore */ }\r",
									"\r",
									"// Utility: slugify the expected name (kebab-case)\r",
									"const slugify = (s) => String(s || \"\")\r",
									"  .trim()\r",
									"  .toLowerCase()\r",
									"  .replace(/[^a-z0-9]+/g, \"-\")\r",
									"  .replace(/^-+|-+$/g, \"\");\r",
									"\r",
									"// --- 2) “Expected vs Actual” body checks (dynamic) --------------------------\r",
									"pm.test(\"Body matches expected (name, image, slug)\", function () {\r",
									"  // name should mirror what we sent (e.g., {{New Category}} from pre-script)\r",
									"  if (reqBody.name) pm.expect(res.name, \"name\").to.equal(reqBody.name);\r",
									"\r",
									"  // image should mirror request (if you sent one)\r",
									"  if (reqBody.image) pm.expect(res.image, \"image\").to.equal(reqBody.image);\r",
									"\r",
									"  // slug should be derived from name (many APIs do this)\r",
									"  if (reqBody.name) {\r",
									"    const expectedSlug = slugify(reqBody.name);\r",
									"    pm.expect(res.slug, \"slug derived from name\").to.equal(expectedSlug);\r",
									"  }\r",
									"});\r",
									"\r",
									"// --- 3) JSON Schema (object) -----------------------------------------------\r",
									"const schema = {\r",
									"  type: \"object\",\r",
									"  required: [\"id\",\"name\",\"slug\",\"image\",\"creationAt\",\"updatedAt\"],\r",
									"  additionalProperties: true,\r",
									"  properties: {\r",
									"    id:         { type: \"number\" },\r",
									"    name:       { type: \"string\", minLength: 1 },\r",
									"    slug:       { type: \"string\", pattern: \"^[a-z0-9-]+$\" },\r",
									"    image:      { type: \"string\", pattern: \"^https?://.+\" },\r",
									"    creationAt: { type: \"string\", format: \"date-time\" },\r",
									"    updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"  }\r",
									"};\r",
									"\r",
									"pm.test(\"JSON matches category schema\", function () {\r",
									"  pm.response.to.have.jsonSchema(schema);\r",
									"});\r",
									"\r",
									"// --- 4) Save id + slug for reuse -------------------------------------------\r",
									"pm.collectionVariables.set(\"lastCategoryId\", res.id);\r",
									"pm.collectionVariables.set(\"lastCategorySlug\", res.slug);\r",
									"console.log(\"💾 Saved:\", {\r",
									"  lastCategoryId: pm.collectionVariables.get(\"lastCategoryId\"),\r",
									"  lastCategorySlug: pm.collectionVariables.get(\"lastCategorySlug\")\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{New Category}}\",\r\n  \"image\": \"https://placeimg.com/640/480/any\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseurl}}/categories/",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"categories",
								""
							]
						}
					},
					"response": []
				},
				{
					"name": "Get a single category by ID",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- 1) Status + parse + log -----------------------------------------------\r",
									"pm.test(\"200 OK & JSON object\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"  pm.response.to.be.withBody;\r",
									"  pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"let res = pm.response.json();\r",
									"pm.expect(res, \"Response JSON required\").to.be.an(\"object\");\r",
									"\r",
									"console.log(\"✅ Category response:\", res);\r",
									"\r",
									"// --- 2) Compare with expected (what you sent) -------------------------------\r",
									"let reqBody = {};\r",
									"try { reqBody = pm.request.body && pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {}; } catch (_) {}\r",
									"const slugify = (s) => String(s || \"\")\r",
									"  .trim()\r",
									"  .toLowerCase()\r",
									"  .replace(/[^a-z0-9]+/g, \"-\")\r",
									"  .replace(/^-+|-+$/g, \"\");\r",
									"\r",
									"// Name & image should match request (if provided)\r",
									"pm.test(\"Matches expected name/image/slug\", function () {\r",
									"  if (reqBody.name)  pm.expect(res.name,  \"name\").to.equal(reqBody.name);\r",
									"  if (reqBody.image) pm.expect(res.image, \"image\").to.equal(reqBody.image);\r",
									"  if (reqBody.name)  pm.expect(res.slug,  \"slug derived from name\").to.equal(slugify(reqBody.name));\r",
									"});\r",
									"\r",
									"// --- 3) JSON Schema ---------------------------------------------------------\r",
									"const schema = {\r",
									"  type: \"object\",\r",
									"  required: [\"id\",\"name\",\"slug\",\"image\",\"creationAt\",\"updatedAt\"],\r",
									"  additionalProperties: true,\r",
									"  properties: {\r",
									"    id:         { type: \"number\" },\r",
									"    name:       { type: \"string\", minLength: 1 },\r",
									"    slug:       { type: \"string\", pattern: \"^[a-z0-9-]+$\" },\r",
									"    image:      { type: \"string\", pattern: \"^https?://.+\" },\r",
									"    creationAt: { type: \"string\", format: \"date-time\" },\r",
									"    updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"  }\r",
									"};\r",
									"\r",
									"pm.test(\"JSON matches category schema\", function () {\r",
									"  pm.response.to.have.jsonSchema(schema);\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/categories/{{lastCategoryId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"categories",
								"{{lastCategoryId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get a single category by slug",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- 1) Status + parse + log -----------------------------------------------\r",
									"pm.test(\"200 OK & JSON object\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"  pm.response.to.be.withBody;\r",
									"  pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"let res = pm.response.json();\r",
									"pm.expect(res, \"Response JSON required\").to.be.an(\"object\");\r",
									"\r",
									"console.log(\"✅ Category response:\", res);\r",
									"\r",
									"// --- 2) Compare with expected (what you sent) -------------------------------\r",
									"let reqBody = {};\r",
									"try { reqBody = pm.request.body && pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {}; } catch (_) {}\r",
									"const slugify = (s) => String(s || \"\")\r",
									"  .trim()\r",
									"  .toLowerCase()\r",
									"  .replace(/[^a-z0-9]+/g, \"-\")\r",
									"  .replace(/^-+|-+$/g, \"\");\r",
									"\r",
									"// Name & image should match request (if provided)\r",
									"pm.test(\"Matches expected name/image/slug\", function () {\r",
									"  if (reqBody.name)  pm.expect(res.name,  \"name\").to.equal(reqBody.name);\r",
									"  if (reqBody.image) pm.expect(res.image, \"image\").to.equal(reqBody.image);\r",
									"  if (reqBody.name)  pm.expect(res.slug,  \"slug derived from name\").to.equal(slugify(reqBody.name));\r",
									"});\r",
									"\r",
									"// --- 3) JSON Schema ---------------------------------------------------------\r",
									"const schema = {\r",
									"  type: \"object\",\r",
									"  required: [\"id\",\"name\",\"slug\",\"image\",\"creationAt\",\"updatedAt\"],\r",
									"  additionalProperties: true,\r",
									"  properties: {\r",
									"    id:         { type: \"number\" },\r",
									"    name:       { type: \"string\", minLength: 1 },\r",
									"    slug:       { type: \"string\", pattern: \"^[a-z0-9-]+$\" },\r",
									"    image:      { type: \"string\", pattern: \"^https?://.+\" },\r",
									"    creationAt: { type: \"string\", format: \"date-time\" },\r",
									"    updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"  }\r",
									"};\r",
									"\r",
									"pm.test(\"JSON matches category schema\", function () {\r",
									"  pm.response.to.have.jsonSchema(schema);\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/categories/slug/{{lastCategorySlug}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"categories",
								"slug",
								"{{lastCategorySlug}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get all products by category",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// 1) Status + parse + log",
									"pm.test(\"200 OK & JSON array\", function () {",
									"  pm.response.to.have.status(200);",
									"  pm.response.to.be.withBody;",
									"  pm.response.to.be.json;",
									"});",
									"",
									"let res = pm.response.json();",
									"pm.expect(res, \"Response JSON should be an array\").to.be.an(\"array\");",
									"",
									"console.log(\"✅ Category products response:\", res);",
									"",
									"// 2) Schema for category inside each product",
									"const categorySchema = {",
									"  type: \"object\",",
									"  required: [\"id\",\"name\",\"slug\",\"image\",\"creationAt\",\"updatedAt\"],",
									"  additionalProperties: true,",
									"  properties: {",
									"    id:         { type: \"number\" },",
									"    name:       { type: \"string\", minLength: 1 },",
									"    slug:       { type: \"string\", pattern: \"^[a-z0-9-]+$\" },",
									"    image:      { type: \"string\", pattern: \"^https?://.+\" },",
									"    creationAt: { type: \"string\", format: \"date-time\" },",
									"    updatedAt:  { type: \"string\", format: \"date-time\" }",
									"  }",
									"};",
									"",
									"pm.test(\"Each item is an object with valid category schema\", function () {",
									"  res.forEach(function(item, idx) {",
									"    pm.expect(item, `Item at index ${idx} should be an object`).to.be.an(\"object\");",
									"    pm.expect(item).to.have.property(\"category\");",
									"    pm.expect(item.category, `Category at index ${idx} should be an object`).to.be.an(\"object\");",
									"    pm.expect(item.category).to.have.jsonSchema(categorySchema);",
									"  });",
									"});",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/categories/1/products",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"categories",
								"1",
								"products"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update a category",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// ---- Helpers ----\r",
									"const pick = (a) => a[Math.floor(Math.random() * a.length)];\r",
									"const adjectives = [\"Modern\",\"Classic\",\"Premium\",\"Urban\",\"Vintage\",\"Eco\",\"Cozy\",\"Elegant\",\"Fresh\",\"Bold\",\"Smart\",\"Heritage\",\"Everyday\",\"Elite\",\"Royal\"];\r",
									"const nouns      = [\"Styles\",\"Essentials\",\"Collection\",\"Goods\",\"Basics\",\"Picks\",\"Edition\",\"Finds\",\"Threads\",\"Wardrobe\",\"Selection\",\"Items\"];\r",
									"\r",
									"// short unique token (base36) to avoid duplicate slugs\r",
									"const token = Math.random().toString(36).slice(2, 6); // 4 chars\r",
									"\r",
									"// Build name & slug\r",
									"const generatedName = `${pick(adjectives)} ${pick(nouns)} ${token}`;\r",
									"const slugify = (s) => String(s || \"\")\r",
									"  .trim()\r",
									"  .toLowerCase()\r",
									"  .replace(/[^a-z0-9]+/g, \"-\")\r",
									"  .replace(/^-+|-+$/g, \"\");\r",
									"const generatedSlug = slugify(generatedName);\r",
									"\r",
									"// Save for reuse\r",
									"\r",
									"\r",
									"// Update outgoing request body (PATCH/PUT)\r",
									"let body = {};\r",
									"try { body = pm.request.body && pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {}; } catch (_) {}\r",
									"body.name = generatedName;\r",
									"// If your API accepts slug explicitly, keep next line; if slug is auto-generated, you can remove it.\r",
									"body.slug = generatedSlug;\r",
									"\r",
									"// Keep existing image or ensure a default\r",
									"body.image = body.image || \"https://placeimg.com/640/480/any\";\r",
									"\r",
									"// Push back\r",
									"pm.request.headers.upsert({ key: \"Content-Type\", value: \"application/json\" });\r",
									"pm.request.body.update(JSON.stringify(body, null, 2));\r",
									"\r",
									"console.log(\"🏷️ name:\", generatedName, \"🔗 slug:\", generatedSlug);\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// 1) Status & JSON (expect 200 for update endpoints)\r",
									"pm.test(\"200 OK & JSON object\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"  pm.response.to.be.withBody;\r",
									"  pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const res = pm.response.json();\r",
									"console.log(\"✅ Category response:\", res);\r",
									"\r",
									"// If the API sometimes returns an error object with sqlite info, surface it clearly\r",
									"pm.test(\"No FK/UNIQUE constraint error\", function () {\r",
									"  const msg = res && (res.message || res.error || res.name);\r",
									"  pm.expect(\r",
									"    msg && /constraint/i.test(msg) ? false : true,\r",
									"    `Server reported constraint problem: ${msg || \"(none)\"}`\r",
									"  ).to.be.true;\r",
									"});\r",
									"\r",
									"// 2) Match against what we sent\r",
									"let reqBody = {};\r",
									"try { reqBody = pm.request.body && pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {}; } catch (_) {}\r",
									"\r",
									"const slugify = (s) => String(s || \"\")\r",
									"  .trim()\r",
									"  .toLowerCase()\r",
									"  .replace(/[^a-z0-9]+/g, \"-\")\r",
									"  .replace(/^-+|-+$/g, \"\");\r",
									"\r",
									"pm.test(\"Matches requested name/image/slug\", function () {\r",
									"  if (reqBody.name)  pm.expect(res.name,  \"name\").to.equal(reqBody.name);\r",
									"  if (reqBody.image) pm.expect(res.image, \"image\").to.equal(reqBody.image);\r",
									"  if (reqBody.slug)  pm.expect(res.slug,  \"slug equals requested\").to.equal(reqBody.slug);\r",
									"  else if (reqBody.name) pm.expect(res.slug, \"slug derived from name\").to.equal(slugify(reqBody.name));\r",
									"});\r",
									"\r",
									"// 3) Schema validation\r",
									"const schema = {\r",
									"  type: \"object\",\r",
									"  required: [\"id\",\"name\",\"slug\",\"image\",\"creationAt\",\"updatedAt\"],\r",
									"  additionalProperties: true,\r",
									"  properties: {\r",
									"    id:         { type: \"number\" },\r",
									"    name:       { type: \"string\", minLength: 1 },\r",
									"    slug:       { type: \"string\", pattern: \"^[a-z0-9-]+$\" },\r",
									"    image:      { type: \"string\", pattern: \"^https?://.+\" },\r",
									"    creationAt: { type: \"string\", format: \"date-time\" },\r",
									"    updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"  }\r",
									"};\r",
									"\r",
									"pm.test(\"JSON matches category schema\", function () {\r",
									"  pm.response.to.have.jsonSchema(schema);\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{Updated Category Name}}\",\r\n  \"image\": \"https://placeimg.com/640/480/any\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseurl}}/categories/{{lastCategoryId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"categories",
								"{{lastCategoryId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete a category",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{token}}",
									"type": "string"
								}
							]
						},
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/categories/{{lastCategoryId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"categories",
								"{{lastCategoryId}}"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Filter Products",
			"item": [
				{
					"name": "Filter Products",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- 1) Status + parse + logs ----------------------------------------------\r",
									"pm.test(\"200 OK & JSON array\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"  pm.response.to.be.withBody;\r",
									"  pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const da6 = pm.response.json();\r",
									"pm.expect(Array.isArray(da6), \"Response should be an array\").to.be.true;\r",
									"\r",
									"console.log(\"📦 Total Filter products:\", da6.length);\r",
									"console.log(\"🔎 Sample (first 3):\", da6.slice(0, 3).map(p => ({\r",
									"  id: p.id, title: p.title, price: p.price, cat: p?.category?.slug\r",
									"})));\r",
									"\r",
									"// --- 2) Lightweight dynamic checks (simplified) -----------------------------\r",
									"pm.test(\"Basic structure sanity\", function () {\r",
									"  if (da6.length > 0) {\r",
									"    const p = da6[0];\r",
									"    pm.expect(p).to.be.an(\"object\");\r",
									"    pm.expect(p).to.have.property(\"id\");\r",
									"    pm.expect(p).to.have.property(\"title\");\r",
									"    // (Removed) deep type/shape checks, loops over all items, and array/type assertions for nested fields\r",
									"  }\r",
									"});\r",
									"\r",
									"// --- 3) JSON Schema (removed to simplify assertions) ------------------------\r",
									"// (Removed) pm.response.to.have.jsonSchema(schema);\r",
									"\r",
									"// --- 4) Capture exactly ONE product's fields (first item if present) --------\r",
									"if (da6.length > 0) {\r",
									"  const p = da6[0]; // choose first item deterministically\r",
									"  pm.collectionVariables.set(\"filterTitle\", p.title);\r",
									"  pm.collectionVariables.set(\"filterCategoryId\", p.category?.id);\r",
									"  pm.collectionVariables.set(\"filterPrice\", p.price);\r",
									"  pm.collectionVariables.set(\"filterCategorySlug\", p.category?.slug);\r",
									"\r",
									"  console.log(\"💾 Saved (one value each):\", {\r",
									"    filterTitle: pm.collectionVariables.get(\"filterTitle\"),\r",
									"    filterCategoryId: pm.collectionVariables.get(\"filterCategoryId\"),\r",
									"    filterPrice: pm.collectionVariables.get(\"filterPrice\"),\r",
									"    filterCategorySlug: pm.collectionVariables.get(\"filterCategorySlug\")\r",
									"  });\r",
									"} else {\r",
									"  console.warn(\"No products returned; nothing captured.\");\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/products",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products"
							]
						}
					},
					"response": []
				},
				{
					"name": "Filter by Title",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- 1) Status + parse + log -----------------------------------------------\r",
									"pm.test(\"200 OK & JSON array\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"  pm.response.to.be.withBody;\r",
									"  pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const da7 = pm.response.json();\r",
									"pm.expect(Array.isArray(da7), \"Response should be an array\").to.be.true;\r",
									"\r",
									"// Print full response (trim if huge)\r",
									"console.log(\"📦 Filter by Title response:\", da7);\r",
									"\r",
									"// --- 2) Dynamic expectations ------------------------------------------------\r",
									"// Expect category.id in each item to match the path param (:id)\r",
									"const url = pm.request.url.toString();\r",
									"const m = url.match(/\\/categories\\/(\\d+)\\/products/i);\r",
									"const expectedCategoryId = m ? Number(m[1]) : null;\r",
									"\r",
									"// Helper: slugify to kebab-case\r",
									"const slugify = (s) => String(s || \"\")\r",
									"  .trim()\r",
									"  .toLowerCase()\r",
									"  .replace(/[^a-z0-9]+/g, \"-\")\r",
									"  .replace(/^-+|-+$/g, \"\");\r",
									"\r",
									"// Simplified assertions: basic first-item sanity only\r",
									"pm.test(\"Basic structure sanity (first item only)\", function () {\r",
									"  if (da7.length > 0) {\r",
									"    const p = da7[0];\r",
									"    pm.expect(p).to.be.an(\"object\");\r",
									"    pm.expect(p).to.have.property(\"id\");\r",
									"    pm.expect(p).to.have.property(\"title\");\r",
									"  }\r",
									"});\r",
									"\r",
									"// --- 3) JSON Schema (array of products) ------------------------------------\r",
									"// Kept the schema object (non-assert code unchanged)\r",
									"const schema = {\r",
									"  type: \"array\",\r",
									"  items: {\r",
									"    type: \"object\",\r",
									"    required: [\"id\",\"title\",\"slug\",\"price\",\"description\",\"category\",\"images\"],\r",
									"    additionalProperties: true,\r",
									"    properties: {\r",
									"      id:          { type: \"number\" },\r",
									"      title:       { type: \"string\", minLength: 1 },\r",
									"      slug:        { type: \"string\", pattern: \"^[a-z0-9-]+$\" },\r",
									"      // allow number or numeric string (some APIs serialize as string)\r",
									"      price:       { anyOf: [{ type: \"number\" }, { type: \"string\", pattern: \"^-?\\\\d+(\\\\.\\\\d+)?$\" }] },\r",
									"      description: { type: \"string\" },\r",
									"      category: {\r",
									"        type: \"object\",\r",
									"        required: [\"id\",\"name\",\"slug\",\"image\"],\r",
									"        additionalProperties: true,\r",
									"        properties: {\r",
									"          id:    { type: \"number\" },\r",
									"          name:  { type: \"string\" },\r",
									"          slug:  { type: \"string\" },\r",
									"          image: { type: \"string\" }\r",
									"        }\r",
									"      },\r",
									"      images: {\r",
									"        type: \"array\",\r",
									"        items: { type: \"string\" }\r",
									"      },\r",
									"      // optional timestamps if present\r",
									"      creationAt: { type: \"string\", format: \"date-time\" },\r",
									"      updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"    }\r",
									"  }\r",
									"};\r",
									"\r",
									"// (Removed schema assertion to simplify)\r",
									"// pm.test(\"JSON matches expected product array schema\", function () {\r",
									"//   pm.response.to.have.jsonSchema(schema);\r",
									"// });\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/products?title={{filterTitle}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products"
							],
							"query": [
								{
									"key": "title",
									"value": "{{filterTitle}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Filter by Category",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- 1) Status + parse + logs ----------------------------------------------\r",
									"pm.test(\"200 OK & JSON array\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"  pm.response.to.be.withBody;\r",
									"  pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const da7 = pm.response.json();\r",
									"pm.expect(Array.isArray(da7), \"Response should be an array\").to.be.true;\r",
									"\r",
									"console.log(\"📦 Filter by Category products are:\", da7.length);\r",
									"console.log(\"🔎 Sample (first 3):\", da7.slice(0, 3).map(p => ({\r",
									"  id: p.id, title: p.title, price: p.price, cat: p?.category?.slug\r",
									"})));\r",
									"\r",
									"// --- 2) Lightweight dynamic checks (simplified) -----------------------------\r",
									"pm.test(\"Basic structure sanity (first item only)\", function () {\r",
									"  if (da7.length > 0) {\r",
									"    const p = da7[0];\r",
									"    pm.expect(p).to.be.an(\"object\");\r",
									"    pm.expect(p).to.have.property(\"id\");\r",
									"    pm.expect(p).to.have.property(\"title\");\r",
									"  }\r",
									"});\r",
									"\r",
									"// --- 3) JSON Schema (covers entire array) -----------------------------------\r",
									"const schema = {\r",
									"  type: \"array\",\r",
									"  items: {\r",
									"    type: \"object\",\r",
									"    required: [\"id\",\"title\",\"slug\",\"price\",\"description\",\"category\",\"images\"],\r",
									"    additionalProperties: true,\r",
									"    properties: {\r",
									"      id:          { type: \"number\" },\r",
									"      title:       { type: \"string\", minLength: 1 },\r",
									"      slug:        { type: \"string\", pattern: \"^[a-z0-9-]+$\" },\r",
									"      price:       { type: \"number\" },\r",
									"      description: { type: \"string\" },\r",
									"      category: {\r",
									"        type: \"object\",\r",
									"        required: [\"id\",\"name\",\"slug\",\"image\"],\r",
									"        additionalProperties: true,\r",
									"        properties: {\r",
									"          id:         { type: \"number\" },\r",
									"          name:       { type: \"string\", minLength: 1 },\r",
									"          slug:       { type: \"string\", minLength: 1 },\r",
									"          image:      { type: \"string\" },\r",
									"          creationAt: { type: \"string\", format: \"date-time\" },\r",
									"          updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"        }\r",
									"      },\r",
									"      images: {\r",
									"        type: \"array\",\r",
									"        minItems: 1,\r",
									"        items: { type: \"string\" }\r",
									"      },\r",
									"      creationAt: { type: \"string\", format: \"date-time\" },\r",
									"      updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"    }\r",
									"  }\r",
									"};\r",
									"\r",
									"// (Removed schema assertion to simplify assertions)\r",
									"// pm.test(\"JSON matches expected product array schema\", function () {\r",
									"//   pm.response.to.have.jsonSchema(schema);\r",
									"// });\r",
									"\r",
									"// --- 4) Capture exactly ONE product's fields (first item if present) --------\r",
									"if (da7.length > 0) {\r",
									"  const p = da7[0]; // choose first item deterministically\r",
									"  pm.collectionVariables.set(\"filterTitle\", p.title);\r",
									"  pm.collectionVariables.set(\"filterCategoryId\", p.category?.id);\r",
									"  pm.collectionVariables.set(\"filterPrice\", p.price);\r",
									"  pm.collectionVariables.set(\"filterCategorySlug\", p.category?.slug);\r",
									"\r",
									"  console.log(\"💾 Saved (one value each):\", {\r",
									"    filterTitle: pm.collectionVariables.get(\"filterTitle\"),\r",
									"    filterCategoryId: pm.collectionVariables.get(\"filterCategoryId\"),\r",
									"    filterPrice: pm.collectionVariables.get(\"filterPrice\"),\r",
									"    filterCategorySlug: pm.collectionVariables.get(\"filterCategorySlug\")\r",
									"  });\r",
									"} else {\r",
									"  console.warn(\"No products returned; nothing captured.\");\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/products?categoryId={{filterCategoryId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products"
							],
							"query": [
								{
									"key": "categoryId",
									"value": "{{filterCategoryId}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Combining Filters",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- 0) helpers -------------------------------------------------------------\r",
									"const slugify = (s) => String(s || \"\")\r",
									"  .trim()\r",
									"  .toLowerCase()\r",
									"  .replace(/[^a-z0-9]+/g, \"-\")\r",
									"  .replace(/^-+|-+$/g, \"\");\r",
									"\r",
									"const getQueryParam = (urlStr, key) => {\r",
									"  try {\r",
									"    const u = new URL(urlStr);\r",
									"    return u.searchParams.get(key);\r",
									"  } catch { return null; }\r",
									"};\r",
									"\r",
									"const isHttpUrl = (s) => /^https?:\\/\\/.+/i.test(String(s || \"\"));\r",
									"\r",
									"// --- 1) status + parse + basic logs ----------------------------------------\r",
									"pm.test(\"200 OK & JSON array\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"  pm.response.to.be.withBody;\r",
									"  pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const da5 = pm.response.json();\r",
									"pm.expect(Array.isArray(da5), \"Response should be an array\").to.be.true;\r",
									"\r",
									"console.log(\"📦 Products returned:\", da5.length);\r",
									"console.log(\"🔎 Sample (first 3):\", da5.slice(0, 3).map(p => ({\r",
									"  id: p.id, title: p.title, price: p.price, catId: p?.category?.id, slug: p.slug\r",
									"})));\r",
									"\r",
									"// --- 2) read filters from the actual request URL ----------------------------\r",
									"const url = pm.request.url.toString();\r",
									"const filterTitle      = getQueryParam(url, \"title\");\r",
									"const filterCategoryId = getQueryParam(url, \"categoryId\");\r",
									"const priceMinStr      = getQueryParam(url, \"price_min\");\r",
									"const priceMaxStr      = getQueryParam(url, \"price_max\");\r",
									"\r",
									"const priceMin = priceMinStr != null ? Number(priceMinStr) : null;\r",
									"const priceMax = priceMaxStr != null ? Number(priceMaxStr) : null;\r",
									"const catIdNum = filterCategoryId != null ? Number(filterCategoryId) : null;\r",
									"\r",
									"// (Removed) strict requirement for at least one product\r",
									"// pm.test(\"At least one product matches filters\", ...);\r",
									"\r",
									"// --- 3) simplified per-item checks -----------------------------------------\r",
									"pm.test(\"Basic structure sanity (first item only)\", function () {\r",
									"  if (da5.length > 0) {\r",
									"    const p = da5[0];\r",
									"    pm.expect(p).to.be.an(\"object\");\r",
									"    pm.expect(p).to.have.property(\"id\");\r",
									"    pm.expect(p).to.have.property(\"title\");\r",
									"  }\r",
									"});\r",
									"\r",
									"// (Removed) per-item type/slug/price/categoryId/title-contains/range/url validations over full array\r",
									"\r",
									"// --- 4) (Removed) uniqueness/sanity across list -----------------------------\r",
									"// pm.test(\"IDs are unique\", ...);\r",
									"\r",
									"// --- 5) json schema (kept object, removed assertion) ------------------------\r",
									"const productArraySchema = {\r",
									"  type: \"array\",\r",
									"  items: {\r",
									"    type: \"object\",\r",
									"    required: [\"id\",\"title\",\"slug\",\"price\",\"description\",\"category\",\"images\"],\r",
									"    additionalProperties: true,\r",
									"    properties: {\r",
									"      id:          { type: \"number\" },\r",
									"      title:       { type: \"string\", minLength: 1 },\r",
									"      slug:        { type: \"string\", pattern: \"^[a-z0-9-]+$\" },\r",
									"      price:       { type: \"number\" },\r",
									"      description: { type: \"string\" },\r",
									"      category: {\r",
									"        type: \"object\",\r",
									"        required: [\"id\",\"name\",\"slug\",\"image\"],\r",
									"        additionalProperties: true,\r",
									"        properties: {\r",
									"          id:         { type: \"number\" },\r",
									"          name:       { type: \"string\", minLength: 1 },\r",
									"          slug:       { type: \"string\", minLength: 1 },\r",
									"          image:      { type: \"string\", pattern: \"^https?://.+\" },\r",
									"          creationAt: { type: \"string\", format: \"date-time\" },\r",
									"          updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"        }\r",
									"      },\r",
									"      images: { type: \"array\", minItems: 1, items: { type: \"string\", pattern: \"^https?://.+\" } },\r",
									"      creationAt: { type: \"string\", format: \"date-time\" },\r",
									"      updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"    }\r",
									"  }\r",
									"};\r",
									"\r",
									"// pm.test(\"JSON matches expected product array schema\", function () {\r",
									"//   pm.response.to.have.jsonSchema(productArraySchema);\r",
									"// });\r",
									"\r",
									"// --- 6) capture a deterministic sample for reuse ----------------------------\r",
									"if (da5.length > 0) {\r",
									"  const p = da5[0];\r",
									"  pm.collectionVariables.set(\"filterTitle\", p.title);\r",
									"  pm.collectionVariables.set(\"filterCategoryId\", p.category?.id);\r",
									"  pm.collectionVariables.set(\"filterPrice\", p.price);\r",
									"  pm.collectionVariables.set(\"filterCategorySlug\", p.category?.slug);\r",
									"  console.log(\"💾 Saved:\", {\r",
									"    filterTitle: pm.collectionVariables.get(\"filterTitle\"),\r",
									"    filterCategoryId: pm.collectionVariables.get(\"filterCategoryId\"),\r",
									"    filterPrice: pm.collectionVariables.get(\"filterPrice\"),\r",
									"    filterCategorySlug: pm.collectionVariables.get(\"filterCategorySlug\")\r",
									"  });\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/products?title={{filterTitle}}&price_min=0&price_max={{filterPrice}}&categoryId={{filterCategoryId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products"
							],
							"query": [
								{
									"key": "title",
									"value": "{{filterTitle}}"
								},
								{
									"key": "price_min",
									"value": "0"
								},
								{
									"key": "price_max",
									"value": "{{filterPrice}}"
								},
								{
									"key": "categoryId",
									"value": "{{filterCategoryId}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Price Range and Category with Pagination",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// --- Generate 0..10 values and randomly flip order ---\r",
									"const r = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;\r",
									"const a = r(0, 1);\r",
									"const b = r(0, 1);\r",
									"const flip = Math.random() < 0.5;\r",
									"\r",
									"const limit  = flip ? a : b;\r",
									"const offset = flip ? b : a;\r",
									"\r",
									"// Set request-local variables (not saved to collection)\r",
									"pm.variables.set(\"limit\",  String(limit));\r",
									"pm.variables.set(\"offset\", String(offset));\r",
									"\r",
									"// Visibility\r",
									"console.log(\"➡️ limit:\", limit, \"offset:\", offset);\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// ============== helpers =====================================================\r",
									"const slugify = (s) => String(s || \"\")\r",
									"  .trim()\r",
									"  .toLowerCase()\r",
									"  .replace(/[^a-z0-9]+/g, \"-\")\r",
									"  .replace(/^-+|-+$/g, \"\");\r",
									"\r",
									"const isHttpUrl = (s) => /^https?:\\/\\/.+/i.test(String(s || \"\"));\r",
									"const isIso = (s) => !Number.isNaN(Date.parse(String(s || \"\")));\r",
									"\r",
									"// ============== 1) status + parse + logs ===================================\r",
									"pm.test(\"200 OK & JSON array\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"  pm.response.to.be.withBody;\r",
									"  pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const da8 = pm.response.json();\r",
									"pm.expect(Array.isArray(da8), \"Response should be an array\").to.be.true;\r",
									"// (Removed) Non-empty array assertion\r",
									"\r",
									"console.log(\"📦 Total products in response:\", da8.length);\r",
									"console.log(\"🔎 Sample(3):\", da8.slice(0, 3).map(p => ({ id: p.id, title: p.title, price: p.price })));\r",
									"\r",
									"// ============== 2) strict per-item data checks ==============================\r",
									"// (Simplified) Only a minimal sanity check on the first item\r",
									"pm.test(\"Basic structure sanity (first item only)\", function () {\r",
									"  if (da8.length > 0) {\r",
									"    const p = da8[0];\r",
									"    pm.expect(p).to.be.an(\"object\");\r",
									"    pm.expect(p).to.have.property(\"id\");\r",
									"    pm.expect(p).to.have.property(\"title\");\r",
									"  }\r",
									"});\r",
									"\r",
									"// (Removed) per-item required fields/types, slug, image URL, category structure, ISO/date ordering\r",
									"\r",
									"// --- NEW price assertion (requested): pass if ANY product is in [0..100] ---\r",
									"// (Removed) price range assertion\r",
									"\r",
									"// Extra strict: IDs must be unique\r",
									"// (Removed) uniqueness check\r",
									"\r",
									"// ============== 3) strict JSON Schema ======================================\r",
									"const schema = {\r",
									"  type: \"array\",\r",
									"  items: {\r",
									"    type: \"object\",\r",
									"    required: [\"id\",\"title\",\"slug\",\"price\",\"description\",\"category\",\"images\",\"creationAt\",\"updatedAt\"],\r",
									"    additionalProperties: true,\r",
									"    properties: {\r",
									"      id:          { type: \"number\" },\r",
									"      title:       { type: \"string\", minLength: 1 },\r",
									"      slug:        { type: \"string\", pattern: \"^[a-z0-9-]+$\" },\r",
									"      price:       { type: \"number\" },\r",
									"      description: { type: \"string\" },\r",
									"      category: {\r",
									"        type: \"object\",\r",
									"        required: [\"id\",\"name\",\"slug\",\"image\",\"creationAt\",\"updatedAt\"],\r",
									"        additionalProperties: true,\r",
									"        properties: {\r",
									"          id:         { type: \"number\" },\r",
									"          name:       { type: \"string\", minLength: 1 },\r",
									"          slug:       { type: \"string\", minLength: 1 },\r",
									"          image:      { type: \"string\", pattern: \"^https?://.+\" },\r",
									"          creationAt: { type: \"string\", format: \"date-time\" },\r",
									"          updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"        }\r",
									"      },\r",
									"      images: {\r",
									"        type: \"array\",\r",
									"        minItems: 1,\r",
									"        items: { type: \"string\", pattern: \"^https?://.+\" }\r",
									"      },\r",
									"      creationAt: { type: \"string\", format: \"date-time\" },\r",
									"      updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"    }\r",
									"  }\r",
									"};\r",
									"\r",
									"// (Removed) schema assertion\r",
									"// pm.test(\"JSON matches strict product array schema\", function () {\r",
									"//   pm.response.to.have.jsonSchema(schema);\r",
									"// });\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/products?price_min=0&price_max={{filterPrice}}&categoryId={{filterCategoryId}}&limit={{limit}}&offset={{offset}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products"
							],
							"query": [
								{
									"key": "price_min",
									"value": "0"
								},
								{
									"key": "price_max",
									"value": "{{filterPrice}}"
								},
								{
									"key": "categoryId",
									"value": "{{filterCategoryId}}"
								},
								{
									"key": "limit",
									"value": "{{limit}}"
								},
								{
									"key": "offset",
									"value": "{{offset}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Filter by Price",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- 1) Status + parse + log -----------------------------------------------\r",
									"pm.test(\"200 OK & JSON array\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"  pm.response.to.be.withBody;\r",
									"  pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const da9 = pm.response.json();\r",
									"pm.expect(Array.isArray(da9), \"Response should be an array\").to.be.true;\r",
									"// (Removed) Non-empty result assertion\r",
									"\r",
									"console.log(\"📦 Products response:\", da9);\r",
									"\r",
									"// Helper utils\r",
									"const slugify = (s) => String(s || \"\")\r",
									"  .trim().toLowerCase().replace(/[^a-z0-9]+/g, \"-\").replace(/^-+|-+$/g, \"\");\r",
									"const isHttpUrl = (s) => /^https?:\\/\\/.+/i.test(String(s || \"\"));\r",
									"const isIsoDate = (s) => !isNaN(Date.parse(s));\r",
									"\r",
									"// --- 2) Strict per-item data validation ------------------------------------\r",
									"// Simplified: only a minimal sanity check on the first item\r",
									"pm.test(\"Basic structure sanity (first item only)\", function () {\r",
									"  if (da9.length > 0) {\r",
									"    const p = da9[0];\r",
									"    pm.expect(p).to.be.an(\"object\");\r",
									"    pm.expect(p).to.have.property(\"id\");\r",
									"    pm.expect(p).to.have.property(\"title\");\r",
									"  }\r",
									"});\r",
									"\r",
									"// (Removed) per-item required fields/types, slug equality, image URL checks,\r",
									"// timestamp validations, category structure checks\r",
									"\r",
									"// (Removed) Uniqueness sanity\r",
									"\r",
									"// --- 3) Tight JSON Schema (array of products) -------------------------------\r",
									"// Schema object kept (non-assert code), assertion removed to simplify\r",
									"const schema = {\r",
									"  type: \"array\",\r",
									"  items: {\r",
									"    type: \"object\",\r",
									"    required: [\"id\",\"title\",\"slug\",\"price\",\"description\",\"category\",\"images\",\"creationAt\",\"updatedAt\"],\r",
									"    additionalProperties: true,\r",
									"    properties: {\r",
									"      id:          { type: \"number\" },\r",
									"      title:       { type: \"string\", minLength: 1 },\r",
									"      slug:        { type: \"string\", pattern: \"^[a-z0-9-]+$\" },\r",
									"      price:       { type: \"number\" },\r",
									"      description: { type: \"string\", minLength: 1 },\r",
									"      category: {\r",
									"        type: \"object\",\r",
									"        required: [\"id\",\"name\",\"slug\",\"image\",\"creationAt\",\"updatedAt\"],\r",
									"        additionalProperties: true,\r",
									"        properties: {\r",
									"          id:         { type: \"number\" },\r",
									"          name:       { type: \"string\", minLength: 1 },\r",
									"          slug:       { type: \"string\", minLength: 1 },\r",
									"          image:      { type: \"string\", pattern: \"^https?://.+\" },\r",
									"          creationAt: { type: \"string\", format: \"date-time\" },\r",
									"          updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"        }\r",
									"      },\r",
									"      images: {\r",
									"        type: \"array\",\r",
									"        minItems: 1,\r",
									"        items: { type: \"string\", pattern: \"^https?://.+\" }\r",
									"      },\r",
									"      creationAt: { type: \"string\", format: \"date-time\" },\r",
									"      updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"    }\r",
									"  }\r",
									"};\r",
									"\r",
									"// pm.test(\"JSON matches expected product array schema\", function () {\r",
									"//   pm.response.to.have.jsonSchema(schema);\r",
									"// });\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/products/?price={{filterPrice}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products",
								""
							],
							"query": [
								{
									"key": "price",
									"value": "{{filterPrice}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Price Range with Pagination",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// --- Random 0..10 for limit/offset (randomly flipped) ---\r",
									"const r = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;\r",
									"const a = r(0, 1);\r",
									"const b = r(0, 1);\r",
									"const flip = Math.random() < 0.5;\r",
									"\r",
									"const limit  = flip ? a : b;\r",
									"const offset = flip ? b : a;\r",
									"\r",
									"pm.variables.set(\"limit\",  String(limit));\r",
									"pm.variables.set(\"offset\", String(offset));\r",
									"\r",
									"// --- price_min / price_max in 0..100 (ensure min ≤ max) ---\r",
									"const pmin = r(0, 0);\r",
									"const pmax = r(pmin, 100);\r",
									"\r",
									"pm.variables.set(\"price_min\", String(pmin));\r",
									"pm.variables.set(\"price_max\", String(pmax));\r",
									"\r",
									"// --- Overwrite/insert query params directly on the URL ---\r",
									"const setParam = (url, key, value) => {\r",
									"  const re = new RegExp(`([?&])${key}=[^&]*`);\r",
									"  return re.test(url)\r",
									"    ? url.replace(re, `$1${key}=${value}`)\r",
									"    : url + (url.includes(\"?\") ? \"&\" : \"?\") + `${key}=${value}`;\r",
									"};\r",
									"\r",
									"let url = pm.request.url.toString();\r",
									"url = setParam(url, \"limit\", limit);\r",
									"url = setParam(url, \"offset\", offset);\r",
									"url = setParam(url, \"price_min\", pmin);\r",
									"url = setParam(url, \"price_max\", pmax);\r",
									"pm.request.url = url;\r",
									"\r",
									"// --- Visibility ---\r",
									"console.log(\"➡️ limit:\", limit, \"offset:\", offset, \"price_min:\", pmin, \"price_max:\", pmax);\r",
									"console.log(\"➡️ URL:\", pm.request.url.toString());\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- 0) helpers -------------------------------------------------------------\r",
									"const slugify = (s) => String(s || \"\")\r",
									"  .trim()\r",
									"  .toLowerCase()\r",
									"  .replace(/[^a-z0-9]+/g, \"-\")\r",
									"  .replace(/^-+|-+$/g, \"\");\r",
									"\r",
									"const isHttpUrl = (s) => /^https?:\\/\\/.+/i.test(String(s || \"\"));\r",
									"const isIsoDate = (s) => !Number.isNaN(Date.parse(String(s || \"\")));\r",
									"\r",
									"// --- 1) Status + parse + log ------------------------------------------------\r",
									"pm.test(\"200 OK & JSON array\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"  pm.response.to.be.withBody;\r",
									"  pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const da11 = pm.response.json();\r",
									"pm.expect(Array.isArray(da11), \"Response must be an array\").to.be.true;\r",
									"\r",
									"console.log(\"📦 Products count:\", da11.length);\r",
									"console.log(\"🔎 Sample (first 3):\", da11.slice(0, 3).map(p => ({\r",
									"  id: p.id, title: p.title, price: p.price, catId: p?.category?.id, slug: p.slug\r",
									"})));\r",
									"\r",
									"// --- 2) Simplified data checks ---------------------------------------------\r",
									"// Minimal sanity on the first item only (no deep/type/url/date/loop checks)\r",
									"pm.test(\"Basic structure sanity (first item only)\", function () {\r",
									"  if (da11.length > 0) {\r",
									"    const p = da11[0];\r",
									"    pm.expect(p).to.be.an(\"object\");\r",
									"    pm.expect(p).to.have.property(\"id\");\r",
									"    pm.expect(p).to.have.property(\"title\");\r",
									"  }\r",
									"});\r",
									"\r",
									"// --- 3) Strict JSON SCHEMA --------------------------------------------------\r",
									"// Keep schema object (non-assert code) but remove the assertion for simplicity\r",
									"const schema = {\r",
									"  type: \"array\",\r",
									"  items: {\r",
									"    type: \"object\",\r",
									"    required: [\"id\",\"title\",\"slug\",\"price\",\"description\",\"category\",\"images\",\"creationAt\",\"updatedAt\"],\r",
									"    additionalProperties: true,\r",
									"    properties: {\r",
									"      id:          { type: \"number\" },\r",
									"      title:       { type: \"string\", minLength: 1 },\r",
									"      slug:        { type: \"string\", pattern: \"^[a-z0-9-]+$\" },\r",
									"      price:       { type: \"number\" },\r",
									"      description: { type: \"string\", minLength: 1 },\r",
									"      category: {\r",
									"        type: \"object\",\r",
									"        required: [\"id\",\"name\",\"slug\",\"image\",\"creationAt\",\"updatedAt\"],\r",
									"        additionalProperties: true,\r",
									"        properties: {\r",
									"          id:         { type: \"number\" },\r",
									"          name:       { type: \"string\", minLength: 1 },\r",
									"          // dataset uses hyphen or underscore; allow both\r",
									"          slug:       { type: \"string\", pattern: \"^[a-z0-9\\\\-_]+$\" },\r",
									"          image:      { type: \"string\", pattern: \"^https?://.+\" },\r",
									"          creationAt: { type: \"string\", format: \"date-time\" },\r",
									"          updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"        }\r",
									"      },\r",
									"      images: { type: \"array\", minItems: 1, items: { type: \"string\", pattern: \"^https?://.+\" } },\r",
									"      creationAt: { type: \"string\", format: \"date-time\" },\r",
									"      updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"    }\r",
									"  }\r",
									"};\r",
									"\r",
									"// (Removed) Schema assertion\r",
									"// pm.test(\"JSON matches strict product array schema\", function () {\r",
									"//   pm.response.to.have.jsonSchema(schema);\r",
									"// });\r",
									"\r",
									"// --- 4) Final full response log (optional) ----------------------------------\r",
									"console.log(\"✅ Full products payload:\", da11);\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/products?price_min={{price_min}}&price_max={{price_max}}&limit={{limit}}&offset={{offset}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products"
							],
							"query": [
								{
									"key": "price_min",
									"value": "{{price_min}}"
								},
								{
									"key": "price_max",
									"value": "{{price_max}}"
								},
								{
									"key": "limit",
									"value": "{{limit}}"
								},
								{
									"key": "offset",
									"value": "{{offset}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Filter by Category Slug",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// --- helpers ---------------------------------------------------------------\r",
									"const slugify = (s) => String(s || \"\")\r",
									"  .trim()\r",
									"  .toLowerCase()\r",
									"  .replace(/[^a-z0-9]+/g, \"-\")\r",
									"  .replace(/^-+|-+$/g, \"\");\r",
									"const isHttpUrl = (s) => /^https?:\\/\\/.+/i.test(String(s || \"\"));\r",
									"const isIso = (s) => !Number.isNaN(Date.parse(s || \"\"));\r",
									"\r",
									"// --- 1) Status + parse + count --------------------------------------------\r",
									"pm.test(\"200 OK & JSON array\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"  pm.response.to.be.withBody;\r",
									"  pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const d12 = pm.response.json();\r",
									"pm.expect(Array.isArray(d12), \"Response should be an array\").to.be.true;\r",
									"\r",
									"console.log(\"📦 Total products:\", d12.length);\r",
									"console.log(\"🔎 Sample (first 3):\", d12.slice(0, 3).map(p => ({\r",
									"  id: p.id, title: p.title, price: p.price, slug: p.slug, cat: p?.category?.slug\r",
									"})));\r",
									"\r",
									"// --- 2) Simplified per-item checks -----------------------------------------\r",
									"pm.test(\"Basic structure sanity (first item only)\", function () {\r",
									"  if (d12.length > 0) {\r",
									"    const p = d12[0];\r",
									"    pm.expect(p).to.be.an(\"object\");\r",
									"    pm.expect(p).to.have.property(\"id\");\r",
									"    pm.expect(p).to.have.property(\"title\");\r",
									"  }\r",
									"});\r",
									"\r",
									"// (Removed) detailed per-item validations: required fields list, type checks,\r",
									"// slug equality, timestamp ISO/order, image URL checks, category shape, price >= 0\r",
									"\r",
									"// (Removed) IDs must be unique across the list\r",
									"\r",
									"// --- 3) Strict JSON SCHEMA (array of products) ------------------------------\r",
									"const schema = {\r",
									"  type: \"array\",\r",
									"  items: {\r",
									"    type: \"object\",\r",
									"    required: [\"id\",\"title\",\"slug\",\"price\",\"description\",\"category\",\"images\",\"creationAt\",\"updatedAt\"],\r",
									"    additionalProperties: true,\r",
									"    properties: {\r",
									"      id:          { type: \"number\" },\r",
									"      title:       { type: \"string\", minLength: 1 },\r",
									"      slug:        { type: \"string\", pattern: \"^[a-z0-9-]+$\" },\r",
									"      price:       { type: \"number\", minimum: 0 },\r",
									"      description: { type: \"string\" },\r",
									"      category: {\r",
									"        type: \"object\",\r",
									"        required: [\"id\",\"name\",\"slug\",\"image\",\"creationAt\",\"updatedAt\"],\r",
									"        additionalProperties: true,\r",
									"        properties: {\r",
									"          id:         { type: \"number\" },\r",
									"          name:       { type: \"string\", minLength: 1 },\r",
									"          slug:       { type: \"string\", pattern: \"^[a-z0-9-]+$\" },\r",
									"          image:      { type: \"string\", pattern: \"^https?://.+\" },\r",
									"          creationAt: { type: \"string\", format: \"date-time\" },\r",
									"          updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"        }\r",
									"      },\r",
									"      images: {\r",
									"        type: \"array\",\r",
									"        minItems: 1,\r",
									"        items: { type: \"string\", pattern: \"^https?://.+\" }\r",
									"      },\r",
									"      creationAt: { type: \"string\", format: \"date-time\" },\r",
									"      updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"    }\r",
									"  }\r",
									"};\r",
									"\r",
									"// (Removed) schema assertion to keep checks minimal\r",
									"// pm.test(\"JSON matches strict product array schema\", function () {\r",
									"//   pm.response.to.have.jsonSchema(schema);\r",
									"// });\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/products?categorySlug={{filterCategorySlug}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products"
							],
							"query": [
								{
									"key": "categorySlug",
									"value": "{{filterCategorySlug}}"
								}
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Users",
			"item": [
				{
					"name": "Get Users",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// 1) Status + JSON array\r",
									"pm.test(\"200 OK & JSON array\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"  pm.response.to.be.withBody;\r",
									"  pm.response.to.be.json;\r",
									"\r",
									"  const data = pm.response.json();\r",
									"  pm.expect(Array.isArray(data), \"Response should be an array\").to.be.true;\r",
									"\r",
									"  console.log(\"🧮 Total items:\", data.length);\r",
									"  console.log(\"🔎 Sample:\", (data || []).slice(0, 3).map(u => ({ id: u.id, email: u.email, name: u.name })));\r",
									"});\r",
									"\r",
									"// 2) One schema to validate everything per item (avatar relaxed)\r",
									"const schema = {\r",
									"  type: \"array\",\r",
									"  items: {\r",
									"    type: \"object\",\r",
									"    required: [\"id\",\"email\",\"password\",\"name\",\"role\",\"avatar\",\"creationAt\",\"updatedAt\"],\r",
									"    additionalProperties: true,\r",
									"    properties: {\r",
									"      id:         { type: \"number\" },\r",
									"      email:      { type: \"string\", pattern: \"^[^\\\\s@]+@[^\\\\s@]+\\\\.[^\\\\s@]+$\" },\r",
									"      password:   { type: \"string\", pattern: \"^[A-Za-z0-9]+$\" },     // letters & digits only\r",
									"      name:       { type: \"string\", minLength: 1 },\r",
									"      role:       { type: \"string\", enum: [\"admin\",\"customer\"] },\r",
									"      // Relaxed to allow current dataset; we'll warn separately if not http/https\r",
									"      avatar:     { type: \"string\", minLength: 1 },\r",
									"      creationAt: { type: \"string\", format: \"date-time\" },\r",
									"      updatedAt:  { type: \"string\", format: \"date-time\" }\r",
									"    }\r",
									"  }\r",
									"};\r",
									"\r",
									"pm.test(\"JSON matches user array schema\", function () {\r",
									"  pm.response.to.have.jsonSchema(schema);\r",
									"});\r",
									"\r",
									"// 3) Soft check (no failure): warn if avatar not http/https\r",
									"(function () {\r",
									"  const data = pm.response.json();\r",
									"  const bad = [];\r",
									"  const urlRe = /^https?:\\/\\/.+/i;\r",
									"  data.forEach((u, i) => { if (!urlRe.test(u.avatar)) bad.push(i); });\r",
									"  if (bad.length) {\r",
									"    console.warn(`⚠️ avatar not http/https at indices:`, bad.slice(0, 10), bad.length > 10 ? `(+${bad.length-10} more)` : \"\");\r",
									"  }\r",
									"})();\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/users",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"users"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create a User",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// --- 1) Helpers -------------------------------------------------------------\r",
									"const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];\r",
									"const firstNames = [\"Nicolas\",\"Aarav\",\"Isha\",\"Rohan\",\"Maya\",\"Liam\",\"Sophia\",\"Arjun\",\"Noah\",\"Ava\",\"Kabir\",\"Anaya\",\"Ethan\",\"Olivia\",\"Vihaan\",\"Sara\"];\r",
									"const lastNames  = [\"Patel\",\"Sharma\",\"Gupta\",\"Roy\",\"Das\",\"Smith\",\"Brown\",\"Johnson\",\"Singh\",\"Mehta\",\"Khan\",\"Bose\",\"Ghosh\",\"Taylor\",\"Lee\",\"Martin\"];\r",
									"\r",
									"const first = pick(firstNames);\r",
									"const last  = pick(lastNames);\r",
									"const fullName = `${first} ${last}`;\r",
									"\r",
									"// Unique-ish Gmail each run\r",
									"const suffix = Date.now().toString().slice(-6);\r",
									"const email  = `${first.toLowerCase()}.${last.toLowerCase()}${suffix}@gmail.com`;\r",
									"\r",
									"// --- 2) Alphanumeric-only password (letters+digits only) -------------------\r",
									"// Pattern: 6 letters from name(s) + 4 digits (total 10 chars, all [A-Za-z0-9])\r",
									"const lettersRaw = (first + last).replace(/[^A-Za-z]/g, \"\");\r",
									"const pad = \"QwertyUiopAsDfGhJkL\"; // fallback letters if needed\r",
									"const lettersPart = (lettersRaw + pad).slice(0, 6);\r",
									"const digitsPart  = Math.floor(100000 + Math.random() * 900000).toString().slice(0, 4);\r",
									"const password = lettersPart.charAt(0).toUpperCase() + lettersPart.slice(1).toLowerCase() + digitsPart; \r",
									"// Example: \"Nicolas\" + \"Patel\" -> \"Nicolas\" -> \"Nicolas1234\" (only letters & numbers)\r",
									"\r",
									"// --- 3) Read current raw JSON body (or start fresh) ------------------------\r",
									"let body = {};\r",
									"try {\r",
									"  body = pm.request.body && pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};\r",
									"} catch (e) {\r",
									"  body = {};\r",
									"}\r",
									"\r",
									"// --- 4) Inject values -------------------------------------------------------\r",
									"body.name     = fullName;\r",
									"body.email    = email;\r",
									"body.password = password;\r",
									"body.avatar   = body.avatar || \"https://picsum.photos/800\";\r",
									"\r",
									"// --- 5) Update request body -------------------------------------------------\r",
									"pm.request.headers.upsert({ key: \"Content-Type\", value: \"application/json\" });\r",
									"pm.request.body.update(JSON.stringify(body, null, 2));\r",
									"\r",
									"// Optional: log to Postman Console\r",
									"console.log(\"Generated payload:\", body);\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// ---- 1) Parse response + request body -------------------------------------\r",
									"pm.test(\"Response is JSON\", function () {\r",
									"  pm.response.to.have.header(\"Content-Type\");\r",
									"  pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\r",
									"});\r",
									"\r",
									"let res;\r",
									"pm.test(\"Parse JSON response\", function () {\r",
									"  res = pm.response.json();\r",
									"  pm.expect(res).to.be.an(\"object\");\r",
									"});\r",
									"\r",
									"let expected = {};\r",
									"pm.test(\"Read raw JSON request body\", function () {\r",
									"  const raw = pm.request?.body?.raw || \"{}\";\r",
									"  expected = JSON.parse(raw);\r",
									"  pm.expect(expected).to.be.an(\"object\");\r",
									"});\r",
									"\r",
									"// ---- 2) Status code assertions --------------------------------------------\r",
									"pm.test(\"Status code is 200 or 201 (created)\", function () {\r",
									"  pm.expect(pm.response.code).to.be.oneOf([200, 201]);\r",
									"});\r",
									"\r",
									"// ---- 3) Field equality: response vs request -------------------------------\r",
									"// Email: compare case-insensitively\r",
									"pm.test(\"Email matches request (case-insensitive)\", function () {\r",
									"  pm.expect(res.email?.toLowerCase()).to.eql(expected.email?.toLowerCase());\r",
									"});\r",
									"\r",
									"// Name: compare after trimming spaces\r",
									"pm.test(\"Name matches request (trimmed)\", function () {\r",
									"  pm.expect((res.name || \"\").trim()).to.eql((expected.name || \"\").trim());\r",
									"});\r",
									"\r",
									"// Password: only check if API echoes it (some APIs don't)\r",
									"pm.test(\"Password matches request (if echoed)\", function () {\r",
									"  if (typeof res.password !== \"undefined\") {\r",
									"    pm.expect(res.password).to.eql(expected.password);\r",
									"  } else {\r",
									"    console.warn(\"Password not echoed by API; skipping password equality check.\");\r",
									"  }\r",
									"});\r",
									"\r",
									"// Avatar: if you sent one, ensure server stored something that looks like a URL\r",
									"pm.test(\"Avatar present (URL-like)\", function () {\r",
									"  pm.expect(res.avatar).to.be.a(\"string\");\r",
									"  pm.expect(res.avatar).to.match(/^https?:\\/\\/.+/);\r",
									"});\r",
									"\r",
									"// ---- 4) Basic shape/type validations --------------------------------------\r",
									"pm.test(\"Has numeric id\", function () {\r",
									"  pm.expect(res).to.have.property(\"id\");\r",
									"  pm.expect(res.id).to.be.a(\"number\");\r",
									"});\r",
									"\r",
									"pm.test(\"Has role string\", function () {\r",
									"  pm.expect(res.role).to.be.a(\"string\");\r",
									"});\r",
									"\r",
									"pm.test(\"creationAt and updatedAt are valid ISO timestamps\", function () {\r",
									"  const isValid = (s) => !!s && !isNaN(Date.parse(s));\r",
									"  pm.expect(isValid(res.creationAt)).to.eql(true);\r",
									"  pm.expect(isValid(res.updatedAt)).to.eql(true);\r",
									"});\r",
									"\r",
									"// ---- 5) Log success + full JSON response ----------------------------------\r",
									"console.log(\"✅ user created\");\r",
									"console.log(\"Response JSON:\", JSON.stringify(res, null, 2));\r",
									"\r",
									"// (Optional) Save values for later requests\r",
									"pm.environment.set(\"last_user_id\", res.id);\r",
									"pm.environment.set(\"last_user_email\", res.email);\r",
									"\r",
									"// ---- 6) JSON Schema validation --------------------------------------------\r",
									"const schema = {\r",
									"  \"type\": \"object\",\r",
									"  \"properties\": {\r",
									"    \"id\":        { \"type\": \"integer\" },\r",
									"    \"email\":     { \"type\": \"string\" },\r",
									"    \"password\":  { \"type\": \"string\" },\r",
									"    \"name\":      { \"type\": \"string\" },\r",
									"    \"role\":      { \"type\": \"string\" },\r",
									"    \"avatar\":    { \"type\": \"string\" },\r",
									"    \"creationAt\":{ \"type\": \"string\" },\r",
									"    \"updatedAt\": { \"type\": \"string\" }\r",
									"  },\r",
									"  \"required\": [\r",
									"    \"id\",\r",
									"    \"email\",\r",
									"    \"password\",\r",
									"    \"name\",\r",
									"    \"role\",\r",
									"    \"avatar\",\r",
									"    \"creationAt\",\r",
									"    \"updatedAt\"\r",
									"  ]\r",
									"};\r",
									"\r",
									"pm.test(\"Response JSON matches the expected schema\", function () {\r",
									"  pm.response.to.have.jsonSchema(schema);\r",
									"});\r",
									"// ---- 4a) Capture UserId ASAP (before other assertions can throw) ----------\r",
									"try {\r",
									"  if (res && typeof res.id !== \"undefined\" && res.id !== null) {\r",
									"    // Normalize to number if possible, otherwise keep as-is\r",
									"    const idNum = Number(res.id);\r",
									"    const toStore = isNaN(idNum) ? res.id : idNum;\r",
									"\r",
									"    // Write to collection variable\r",
									"    pm.collectionVariables.set(\"UserId\", toStore);\r",
									"\r",
									"    // Optional mirror to environment (useful for Runner/Newman)\r",
									"    pm.environment.set(\"UserId\", String(res.id));\r",
									"\r",
									"    console.log(\"📦 Saved collection variable UserId =\", pm.collectionVariables.get(\"UserId\"));\r",
									"  } else {\r",
									"    console.warn(\"No 'id' found in response body; skip saving UserId.\");\r",
									"  }\r",
									"} catch (e) {\r",
									"  console.error(\"Failed to save UserId:\", e);\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{generated_name}}\",\r\n  \"email\": \"{{generated_email}}\",\r\n  \"password\": \"{{generated_password}}\",\r\n  \"avatar\": \"https://picsum.photos/800\"\r\n}\r\n",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseurl}}/users/",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"users",
								""
							]
						}
					},
					"response": []
				},
				{
					"name": "Get a Single User",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// ---- 1) Basic status + JSON checks ----------------------------------------\r",
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Response has JSON body\", function () {\r",
									"  pm.response.to.be.withBody;\r",
									"  pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"// ---- 2) Parse JSON safely --------------------------------------------------\r",
									"let json;\r",
									"try {\r",
									"  json = pm.response.json();\r",
									"} catch (e) {\r",
									"  json = null;\r",
									"}\r",
									"pm.expect(json, \"Body should be valid JSON\").to.be.an(\"object\");\r",
									"\r",
									"// Print the response for visibility\r",
									"console.log(\"✅ Captured the single User:\", json);\r",
									"\r",
									"// ---- 3) Dynamic schema-like validation (no hard-coded values) -------------\r",
									"pm.test(\"Has required fields with correct types\", function () {\r",
									"  pm.expect(json).to.have.property(\"id\").that.is.a(\"number\");\r",
									"  pm.expect(json).to.have.property(\"email\").that.is.a(\"string\").and.not.empty;\r",
									"  pm.expect(json).to.have.property(\"password\").that.is.a(\"string\").and.not.empty;\r",
									"  pm.expect(json).to.have.property(\"name\").that.is.a(\"string\").and.not.empty;\r",
									"  pm.expect(json).to.have.property(\"role\").that.is.a(\"string\").and.not.empty;\r",
									"  pm.expect(json).to.have.property(\"avatar\").that.is.a(\"string\").and.not.empty;\r",
									"  pm.expect(json).to.have.property(\"creationAt\").that.is.a(\"string\").and.not.empty;\r",
									"  pm.expect(json).to.have.property(\"updatedAt\").that.is.a(\"string\").and.not.empty;\r",
									"});\r",
									"\r",
									"// ---- 4) Field-level validations (patterns) --------------------------------\r",
									"pm.test(\"Email looks valid\", function () {\r",
									"  pm.expect(json.email).to.match(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/);\r",
									"});\r",
									"\r",
									"pm.test(\"Password is alphanumeric only\", function () {\r",
									"  pm.expect(json.password).to.match(/^[A-Za-z0-9]+$/);\r",
									"});\r",
									"\r",
									"pm.test(\"Avatar is a valid URL (http/https)\", function () {\r",
									"  pm.expect(json.avatar).to.match(/^https?:\\/\\/.+/);\r",
									"});\r",
									"\r",
									"pm.test(\"Dates are valid ISO-like timestamps\", function () {\r",
									"  const isValidDate = (s) => !isNaN(Date.parse(s));\r",
									"  pm.expect(isValidDate(json.creationAt)).to.be.true;\r",
									"  pm.expect(isValidDate(json.updatedAt)).to.be.true;\r",
									"});\r",
									"\r",
									"// Optional: updatedAt should be >= creationAt (if both parse)\r",
									"pm.test(\"updatedAt is not earlier than creationAt\", function () {\r",
									"  const c = Date.parse(json.creationAt);\r",
									"  const u = Date.parse(json.updatedAt);\r",
									"  if (!isNaN(c) && !isNaN(u)) {\r",
									"    pm.expect(u).to.be.at.least(c);\r",
									"  }\r",
									"});\r",
									"\r",
									"// ---- 6) JSON Schema validation --------------------------------------------\r",
									"const schema = {\r",
									"  \"type\": \"object\",\r",
									"  \"properties\": {\r",
									"    \"id\":        { \"type\": \"integer\" },\r",
									"    \"email\":     { \"type\": \"string\" },\r",
									"    \"password\":  { \"type\": \"string\" },\r",
									"    \"name\":      { \"type\": \"string\" },\r",
									"    \"role\":      { \"type\": \"string\" },\r",
									"    \"avatar\":    { \"type\": \"string\" },\r",
									"    \"creationAt\":{ \"type\": \"string\" },\r",
									"    \"updatedAt\": { \"type\": \"string\" }\r",
									"  },\r",
									"  \"required\": [\r",
									"    \"id\",\r",
									"    \"email\",\r",
									"    \"password\",\r",
									"    \"name\",\r",
									"    \"role\",\r",
									"    \"avatar\",\r",
									"    \"creationAt\",\r",
									"    \"updatedAt\"\r",
									"  ]\r",
									"};\r",
									"\r",
									"pm.test(\"Response JSON matches the expected schema\", function () {\r",
									"  pm.response.to.have.jsonSchema(schema);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/users/{{UserId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"users",
								"{{UserId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update a User",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Some sample first and last names\r",
									"const firstNames = [\"John\", \"Alice\", \"Michael\", \"Sarah\", \"David\", \"Emma\"];\r",
									"const lastNames = [\"Doe\", \"Smith\", \"Brown\", \"Johnson\", \"Lee\", \"Williams\"];\r",
									"\r",
									"// Pick random first and last name\r",
									"let first = firstNames[Math.floor(Math.random() * firstNames.length)];\r",
									"let last = lastNames[Math.floor(Math.random() * lastNames.length)];\r",
									"\r",
									"// Build natural-looking name and email\r",
									"let name = `${first} ${last}`;\r",
									"let email = `${first.toLowerCase()}.${last.toLowerCase()}${Math.floor(Math.random() * 100)}@mail.com`;\r",
									"\r",
									"// Set environment variables\r",
									"pm.environment.set(\"name\", name);\r",
									"pm.environment.set(\"email\", email);\r",
									"\r",
									"// Log for visibility\r",
									"console.log(\"👤 Name set:\", name);\r",
									"console.log(\"📧 Email set:\", email);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// ---- 1) Basic status + JSON checks ----------------------------------------\r",
									"pm.test(\"Status code is 200 OK\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Response has JSON body\", function () {\r",
									"  pm.response.to.be.withBody;\r",
									"  pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"// ---- 2) Parse JSON safely --------------------------------------------------\r",
									"let json;\r",
									"try {\r",
									"  json = pm.response.json();\r",
									"} catch (e) {\r",
									"  json = null;\r",
									"}\r",
									"pm.expect(json, \"Body should be valid JSON\").to.be.an(\"object\");\r",
									"\r",
									"// Print the response for visibility\r",
									"console.log(\"✅ Updated the single User:\", json);\r",
									"\r",
									"// ---- 3) Dynamic schema-like validation (no hard-coded values) -------------\r",
									"pm.test(\"Has required fields with correct types\", function () {\r",
									"  pm.expect(json).to.have.property(\"id\").that.is.a(\"number\");\r",
									"  pm.expect(json).to.have.property(\"email\").that.is.a(\"string\").and.not.empty;\r",
									"  pm.expect(json).to.have.property(\"password\").that.is.a(\"string\").and.not.empty;\r",
									"  pm.expect(json).to.have.property(\"name\").that.is.a(\"string\").and.not.empty;\r",
									"  pm.expect(json).to.have.property(\"role\").that.is.a(\"string\").and.not.empty;\r",
									"  pm.expect(json).to.have.property(\"avatar\").that.is.a(\"string\").and.not.empty;\r",
									"  pm.expect(json).to.have.property(\"creationAt\").that.is.a(\"string\").and.not.empty;\r",
									"  pm.expect(json).to.have.property(\"updatedAt\").that.is.a(\"string\").and.not.empty;\r",
									"});\r",
									"\r",
									"// ---- 4) Field-level validations (patterns) --------------------------------\r",
									"pm.test(\"Email looks valid\", function () {\r",
									"  pm.expect(json.email).to.match(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/);\r",
									"});\r",
									"\r",
									"pm.test(\"Password is alphanumeric only\", function () {\r",
									"  pm.expect(json.password).to.match(/^[A-Za-z0-9]+$/);\r",
									"});\r",
									"\r",
									"pm.test(\"Avatar is a valid URL (http/https)\", function () {\r",
									"  pm.expect(json.avatar).to.match(/^https?:\\/\\/.+/);\r",
									"});\r",
									"\r",
									"pm.test(\"Dates are valid ISO-like timestamps\", function () {\r",
									"  const isValidDate = (s) => !isNaN(Date.parse(s));\r",
									"  pm.expect(isValidDate(json.creationAt)).to.be.true;\r",
									"  pm.expect(isValidDate(json.updatedAt)).to.be.true;\r",
									"});\r",
									"\r",
									"// Optional: updatedAt should be >= creationAt (if both parse)\r",
									"pm.test(\"updatedAt is not earlier than creationAt\", function () {\r",
									"  const c = Date.parse(json.creationAt);\r",
									"  const u = Date.parse(json.updatedAt);\r",
									"  if (!isNaN(c) && !isNaN(u)) {\r",
									"    pm.expect(u).to.be.at.least(c);\r",
									"  }\r",
									"});\r",
									"\r",
									"// ---- 6) JSON Schema validation --------------------------------------------\r",
									"const schema = {\r",
									"  \"type\": \"object\",\r",
									"  \"properties\": {\r",
									"    \"id\":        { \"type\": \"integer\" },\r",
									"    \"email\":     { \"type\": \"string\" },\r",
									"    \"password\":  { \"type\": \"string\" },\r",
									"    \"name\":      { \"type\": \"string\" },\r",
									"    \"role\":      { \"type\": \"string\" },\r",
									"    \"avatar\":    { \"type\": \"string\" },\r",
									"    \"creationAt\":{ \"type\": \"string\" },\r",
									"    \"updatedAt\": { \"type\": \"string\" }\r",
									"  },\r",
									"  \"required\": [\r",
									"    \"id\",\r",
									"    \"email\",\r",
									"    \"password\",\r",
									"    \"name\",\r",
									"    \"role\",\r",
									"    \"avatar\",\r",
									"    \"creationAt\",\r",
									"    \"updatedAt\"\r",
									"  ]\r",
									"};\r",
									"\r",
									"pm.test(\"Response JSON matches the expected schema\", function () {\r",
									"  pm.response.to.have.jsonSchema(schema);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PUT",
						"header": [
							{
								"key": "content",
								"value": "application/json",
								"type": "text"
							},
							{
								"key": "Authorization",
								"value": "{{vault:json-web-token}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"email\": \"{{email}}\",\r\n  \"name\": \"{{name}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseurl}}/users/{{UserId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"users",
								"{{UserId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Check Email Availability",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 201 created\", function () {\r",
									"  pm.response.to.have.status(201);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"email\": \"john.johnson39@mail.com\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseurl}}/users/is-available",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"users",
								"is-available"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Csv driven Product creation",
			"item": [
				{
					"name": "Create a Product",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Capture CSV-driven variables into request-level variables\r",
									"pm.variables.set(\"title\", data.title);\r",
									"pm.variables.set(\"price\", data.price);\r",
									"\r",
									"// Log for visibility\r",
									"console.log(\"📦 Title from CSV:\", data.title);\r",
									"console.log(\"💲 Price from CSV:\", data.price);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// 1) Assert: 201 Created\r",
									"pm.test(\"Status is 201 Created\", function () {\r",
									"    pm.response.to.have.status(201);\r",
									"});\r",
									"\r",
									"// 2) Parse JSON response safely\r",
									"let resp;\r",
									"pm.test(\"Response is valid JSON\", function () {\r",
									"    resp = pm.response.json();\r",
									"    pm.expect(resp).to.be.an(\"object\");\r",
									"});\r",
									"\r",
									"// 3) Capture \"id\" into collection variable\r",
									"if (resp && resp.id) {\r",
									"    pm.collectionVariables.set(\"csv id\", resp.id);\r",
									"    console.log(\"📌 Captured csv id:\", resp.id);\r",
									"} else {\r",
									"    console.warn(\"⚠️ No id found in response to capture\");\r",
									"}\r",
									"\r",
									"// 4) Validate response body fields\r",
									"pm.test(\"Response body has required fields with correct types\", function () {\r",
									"    pm.expect(resp).to.have.property(\"id\");\r",
									"    pm.expect(Number.isInteger(resp.id)).to.be.true;\r",
									"\r",
									"    pm.expect(resp).to.have.property(\"title\").that.is.a(\"string\").and.not.empty;\r",
									"    pm.expect(resp).to.have.property(\"slug\").that.is.a(\"string\").and.not.empty;\r",
									"\r",
									"    pm.expect(resp).to.have.property(\"price\").that.is.a(\"number\");\r",
									"    pm.expect(resp.price).to.be.at.least(0);\r",
									"\r",
									"    pm.expect(resp).to.have.property(\"description\").that.is.a(\"string\");\r",
									"\r",
									"    pm.expect(resp).to.have.property(\"category\").that.is.an(\"object\");\r",
									"    const c = resp.category;\r",
									"    pm.expect(c).to.have.property(\"id\");\r",
									"    pm.expect(Number.isInteger(c.id)).to.be.true;\r",
									"    pm.expect(c).to.have.property(\"name\").that.is.a(\"string\").and.not.empty;\r",
									"    pm.expect(c).to.have.property(\"slug\").that.is.a(\"string\").and.not.empty;\r",
									"    pm.expect(c).to.have.property(\"image\").that.is.a(\"string\");\r",
									"\r",
									"    pm.expect(resp).to.have.property(\"images\").that.is.an(\"array\").with.length.greaterThan(0);\r",
									"    resp.images.forEach((img, i) => {\r",
									"        pm.expect(img, `images[${i}]`).to.be.a(\"string\").and.not.empty;\r",
									"    });\r",
									"\r",
									"    pm.expect(resp).to.have.property(\"creationAt\").that.is.a(\"string\");\r",
									"    pm.expect(resp).to.have.property(\"updatedAt\").that.is.a(\"string\");\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"title\": \"{{title}}\",\r\n  \"price\": {{price}},\r\n  \"description\": \"A description\",\r\n  \"categoryId\": 10,\r\n  \"images\": [\"https://placehold.co/600x400\"]\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseurl}}/products/",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products",
								""
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete a Product",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Assertion: Status is 200 OK or 404 Not Found\r",
									"pm.test(\"Status is 200 OK or 404 Not Found\", function () {\r",
									"  pm.expect(pm.response.code).to.be.oneOf([200, 404]);\r",
									"});\r",
									"\r",
									"// Assertion: Response time < 3000 ms\r",
									"pm.test(\"Response time < 3000 ms\", function () {\r",
									"  pm.expect(pm.response.responseTime).to.be.below(3000);\r",
									"});\r",
									"\r",
									"// Print on console\r",
									"console.log(\"Product deleted\");"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/products/{{csv id}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"products",
								"{{csv id}}"
							]
						}
					},
					"response": []
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"requests": {},
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"requests": {},
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "Product",
			"value": ""
		},
		{
			"key": "productId",
			"value": ""
		},
		{
			"key": "ProductSlug",
			"value": ""
		},
		{
			"key": "ProductTitle",
			"value": ""
		},
		{
			"key": "UpdateTitle",
			"value": ""
		},
		{
			"key": "UserId",
			"value": ""
		},
		{
			"key": "token",
			"value": ""
		},
		{
			"key": "New Category",
			"value": ""
		},
		{
			"key": "lastCategoryId",
			"value": ""
		},
		{
			"key": "lastCategorySlug",
			"value": ""
		},
		{
			"key": "filterTitle",
			"value": ""
		},
		{
			"key": "filterCategoryId",
			"value": ""
		},
		{
			"key": "filterPrice",
			"value": ""
		},
		{
			"key": "filterCategorySlug",
			"value": ""
		},
		{
			"key": "csv id",
			"value": ""
		}
	]
}